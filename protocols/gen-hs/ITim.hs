{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.3)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module ITim where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Tim_Types
import qualified ITim_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data TimStream_args = TimStream_args  { timStream_args_param :: TimParam
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimStream_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timStream_args_param record  
instance QC.Arbitrary TimStream_args where 
  arbitrary = M.liftM TimStream_args (QC.arbitrary)
  shrink obj | obj == default_TimStream_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimStream_args{timStream_args_param = timStream_args_param obj} then P.Nothing else P.Just $ default_TimStream_args{timStream_args_param = timStream_args_param obj}
    ]
from_TimStream_args :: TimStream_args -> T.ThriftVal
from_TimStream_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v446 -> P.Just (1, ("param",from_TimParam _v446))) $ timStream_args_param record
  ]
write_TimStream_args :: (T.Protocol p, T.Transport t) => p t -> TimStream_args -> P.IO ()
write_TimStream_args oprot record = T.writeVal oprot $ from_TimStream_args record
encode_TimStream_args :: (T.Protocol p, T.Transport t) => p t -> TimStream_args -> LBS.ByteString
encode_TimStream_args oprot record = T.serializeVal oprot $ from_TimStream_args record
to_TimStream_args :: T.ThriftVal -> TimStream_args
to_TimStream_args (T.TStruct fields) = TimStream_args{
  timStream_args_param = P.maybe (timStream_args_param default_TimStream_args) (\(_,_val448) -> (case _val448 of {T.TStruct _val449 -> (to_TimParam (T.TStruct _val449)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_TimStream_args _ = P.error "not a struct"
read_TimStream_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimStream_args
read_TimStream_args iprot = to_TimStream_args <$> T.readVal iprot (T.T_STRUCT typemap_TimStream_args)
decode_TimStream_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimStream_args
decode_TimStream_args iprot bs = to_TimStream_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimStream_args) bs
typemap_TimStream_args :: T.TypeMap
typemap_TimStream_args = Map.fromList [(1,("param",(T.T_STRUCT typemap_TimParam)))]
default_TimStream_args :: TimStream_args
default_TimStream_args = TimStream_args{
  timStream_args_param = default_TimParam}
data TimStream_result = TimStream_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimStream_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimStream_result where 
  arbitrary = QC.elements [TimStream_result]
from_TimStream_result :: TimStream_result -> T.ThriftVal
from_TimStream_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimStream_result :: (T.Protocol p, T.Transport t) => p t -> TimStream_result -> P.IO ()
write_TimStream_result oprot record = T.writeVal oprot $ from_TimStream_result record
encode_TimStream_result :: (T.Protocol p, T.Transport t) => p t -> TimStream_result -> LBS.ByteString
encode_TimStream_result oprot record = T.serializeVal oprot $ from_TimStream_result record
to_TimStream_result :: T.ThriftVal -> TimStream_result
to_TimStream_result (T.TStruct fields) = TimStream_result{

  }
to_TimStream_result _ = P.error "not a struct"
read_TimStream_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimStream_result
read_TimStream_result iprot = to_TimStream_result <$> T.readVal iprot (T.T_STRUCT typemap_TimStream_result)
decode_TimStream_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimStream_result
decode_TimStream_result iprot bs = to_TimStream_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimStream_result) bs
typemap_TimStream_result :: T.TypeMap
typemap_TimStream_result = Map.fromList []
default_TimStream_result :: TimStream_result
default_TimStream_result = TimStream_result{
}
data TimStarttls_args = TimStarttls_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimStarttls_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimStarttls_args where 
  arbitrary = QC.elements [TimStarttls_args]
from_TimStarttls_args :: TimStarttls_args -> T.ThriftVal
from_TimStarttls_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimStarttls_args :: (T.Protocol p, T.Transport t) => p t -> TimStarttls_args -> P.IO ()
write_TimStarttls_args oprot record = T.writeVal oprot $ from_TimStarttls_args record
encode_TimStarttls_args :: (T.Protocol p, T.Transport t) => p t -> TimStarttls_args -> LBS.ByteString
encode_TimStarttls_args oprot record = T.serializeVal oprot $ from_TimStarttls_args record
to_TimStarttls_args :: T.ThriftVal -> TimStarttls_args
to_TimStarttls_args (T.TStruct fields) = TimStarttls_args{

  }
to_TimStarttls_args _ = P.error "not a struct"
read_TimStarttls_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimStarttls_args
read_TimStarttls_args iprot = to_TimStarttls_args <$> T.readVal iprot (T.T_STRUCT typemap_TimStarttls_args)
decode_TimStarttls_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimStarttls_args
decode_TimStarttls_args iprot bs = to_TimStarttls_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimStarttls_args) bs
typemap_TimStarttls_args :: T.TypeMap
typemap_TimStarttls_args = Map.fromList []
default_TimStarttls_args :: TimStarttls_args
default_TimStarttls_args = TimStarttls_args{
}
data TimStarttls_result = TimStarttls_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimStarttls_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimStarttls_result where 
  arbitrary = QC.elements [TimStarttls_result]
from_TimStarttls_result :: TimStarttls_result -> T.ThriftVal
from_TimStarttls_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimStarttls_result :: (T.Protocol p, T.Transport t) => p t -> TimStarttls_result -> P.IO ()
write_TimStarttls_result oprot record = T.writeVal oprot $ from_TimStarttls_result record
encode_TimStarttls_result :: (T.Protocol p, T.Transport t) => p t -> TimStarttls_result -> LBS.ByteString
encode_TimStarttls_result oprot record = T.serializeVal oprot $ from_TimStarttls_result record
to_TimStarttls_result :: T.ThriftVal -> TimStarttls_result
to_TimStarttls_result (T.TStruct fields) = TimStarttls_result{

  }
to_TimStarttls_result _ = P.error "not a struct"
read_TimStarttls_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimStarttls_result
read_TimStarttls_result iprot = to_TimStarttls_result <$> T.readVal iprot (T.T_STRUCT typemap_TimStarttls_result)
decode_TimStarttls_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimStarttls_result
decode_TimStarttls_result iprot bs = to_TimStarttls_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimStarttls_result) bs
typemap_TimStarttls_result :: T.TypeMap
typemap_TimStarttls_result = Map.fromList []
default_TimStarttls_result :: TimStarttls_result
default_TimStarttls_result = TimStarttls_result{
}
data TimLogin_args = TimLogin_args  { timLogin_args_tid :: Tid
  , timLogin_args_pwd :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimLogin_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timLogin_args_tid record   `H.hashWithSalt` timLogin_args_pwd record  
instance QC.Arbitrary TimLogin_args where 
  arbitrary = M.liftM TimLogin_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TimLogin_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimLogin_args{timLogin_args_tid = timLogin_args_tid obj} then P.Nothing else P.Just $ default_TimLogin_args{timLogin_args_tid = timLogin_args_tid obj}
    , if obj == default_TimLogin_args{timLogin_args_pwd = timLogin_args_pwd obj} then P.Nothing else P.Just $ default_TimLogin_args{timLogin_args_pwd = timLogin_args_pwd obj}
    ]
from_TimLogin_args :: TimLogin_args -> T.ThriftVal
from_TimLogin_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v467 -> P.Just (1, ("tid",from_Tid _v467))) $ timLogin_args_tid record
  , (\_v467 -> P.Just (2, ("pwd",T.TString $ E.encodeUtf8 _v467))) $ timLogin_args_pwd record
  ]
write_TimLogin_args :: (T.Protocol p, T.Transport t) => p t -> TimLogin_args -> P.IO ()
write_TimLogin_args oprot record = T.writeVal oprot $ from_TimLogin_args record
encode_TimLogin_args :: (T.Protocol p, T.Transport t) => p t -> TimLogin_args -> LBS.ByteString
encode_TimLogin_args oprot record = T.serializeVal oprot $ from_TimLogin_args record
to_TimLogin_args :: T.ThriftVal -> TimLogin_args
to_TimLogin_args (T.TStruct fields) = TimLogin_args{
  timLogin_args_tid = P.maybe (timLogin_args_tid default_TimLogin_args) (\(_,_val469) -> (case _val469 of {T.TStruct _val470 -> (to_Tid (T.TStruct _val470)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timLogin_args_pwd = P.maybe (timLogin_args_pwd default_TimLogin_args) (\(_,_val469) -> (case _val469 of {T.TString _val471 -> E.decodeUtf8 _val471; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TimLogin_args _ = P.error "not a struct"
read_TimLogin_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimLogin_args
read_TimLogin_args iprot = to_TimLogin_args <$> T.readVal iprot (T.T_STRUCT typemap_TimLogin_args)
decode_TimLogin_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimLogin_args
decode_TimLogin_args iprot bs = to_TimLogin_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimLogin_args) bs
typemap_TimLogin_args :: T.TypeMap
typemap_TimLogin_args = Map.fromList [(1,("tid",(T.T_STRUCT typemap_Tid))),(2,("pwd",T.T_STRING))]
default_TimLogin_args :: TimLogin_args
default_TimLogin_args = TimLogin_args{
  timLogin_args_tid = default_Tid,
  timLogin_args_pwd = ""}
data TimLogin_result = TimLogin_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimLogin_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimLogin_result where 
  arbitrary = QC.elements [TimLogin_result]
from_TimLogin_result :: TimLogin_result -> T.ThriftVal
from_TimLogin_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimLogin_result :: (T.Protocol p, T.Transport t) => p t -> TimLogin_result -> P.IO ()
write_TimLogin_result oprot record = T.writeVal oprot $ from_TimLogin_result record
encode_TimLogin_result :: (T.Protocol p, T.Transport t) => p t -> TimLogin_result -> LBS.ByteString
encode_TimLogin_result oprot record = T.serializeVal oprot $ from_TimLogin_result record
to_TimLogin_result :: T.ThriftVal -> TimLogin_result
to_TimLogin_result (T.TStruct fields) = TimLogin_result{

  }
to_TimLogin_result _ = P.error "not a struct"
read_TimLogin_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimLogin_result
read_TimLogin_result iprot = to_TimLogin_result <$> T.readVal iprot (T.T_STRUCT typemap_TimLogin_result)
decode_TimLogin_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimLogin_result
decode_TimLogin_result iprot bs = to_TimLogin_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimLogin_result) bs
typemap_TimLogin_result :: T.TypeMap
typemap_TimLogin_result = Map.fromList []
default_TimLogin_result :: TimLogin_result
default_TimLogin_result = TimLogin_result{
}
data TimAck_args = TimAck_args  { timAck_args_ab :: TimAckBean
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimAck_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timAck_args_ab record  
instance QC.Arbitrary TimAck_args where 
  arbitrary = M.liftM TimAck_args (QC.arbitrary)
  shrink obj | obj == default_TimAck_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimAck_args{timAck_args_ab = timAck_args_ab obj} then P.Nothing else P.Just $ default_TimAck_args{timAck_args_ab = timAck_args_ab obj}
    ]
from_TimAck_args :: TimAck_args -> T.ThriftVal
from_TimAck_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v479 -> P.Just (1, ("ab",from_TimAckBean _v479))) $ timAck_args_ab record
  ]
write_TimAck_args :: (T.Protocol p, T.Transport t) => p t -> TimAck_args -> P.IO ()
write_TimAck_args oprot record = T.writeVal oprot $ from_TimAck_args record
encode_TimAck_args :: (T.Protocol p, T.Transport t) => p t -> TimAck_args -> LBS.ByteString
encode_TimAck_args oprot record = T.serializeVal oprot $ from_TimAck_args record
to_TimAck_args :: T.ThriftVal -> TimAck_args
to_TimAck_args (T.TStruct fields) = TimAck_args{
  timAck_args_ab = P.maybe (timAck_args_ab default_TimAck_args) (\(_,_val481) -> (case _val481 of {T.TStruct _val482 -> (to_TimAckBean (T.TStruct _val482)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_TimAck_args _ = P.error "not a struct"
read_TimAck_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimAck_args
read_TimAck_args iprot = to_TimAck_args <$> T.readVal iprot (T.T_STRUCT typemap_TimAck_args)
decode_TimAck_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimAck_args
decode_TimAck_args iprot bs = to_TimAck_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimAck_args) bs
typemap_TimAck_args :: T.TypeMap
typemap_TimAck_args = Map.fromList [(1,("ab",(T.T_STRUCT typemap_TimAckBean)))]
default_TimAck_args :: TimAck_args
default_TimAck_args = TimAck_args{
  timAck_args_ab = default_TimAckBean}
data TimAck_result = TimAck_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimAck_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimAck_result where 
  arbitrary = QC.elements [TimAck_result]
from_TimAck_result :: TimAck_result -> T.ThriftVal
from_TimAck_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimAck_result :: (T.Protocol p, T.Transport t) => p t -> TimAck_result -> P.IO ()
write_TimAck_result oprot record = T.writeVal oprot $ from_TimAck_result record
encode_TimAck_result :: (T.Protocol p, T.Transport t) => p t -> TimAck_result -> LBS.ByteString
encode_TimAck_result oprot record = T.serializeVal oprot $ from_TimAck_result record
to_TimAck_result :: T.ThriftVal -> TimAck_result
to_TimAck_result (T.TStruct fields) = TimAck_result{

  }
to_TimAck_result _ = P.error "not a struct"
read_TimAck_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimAck_result
read_TimAck_result iprot = to_TimAck_result <$> T.readVal iprot (T.T_STRUCT typemap_TimAck_result)
decode_TimAck_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimAck_result
decode_TimAck_result iprot bs = to_TimAck_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimAck_result) bs
typemap_TimAck_result :: T.TypeMap
typemap_TimAck_result = Map.fromList []
default_TimAck_result :: TimAck_result
default_TimAck_result = TimAck_result{
}
data TimPresence_args = TimPresence_args  { timPresence_args_pbean :: TimPBean
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimPresence_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timPresence_args_pbean record  
instance QC.Arbitrary TimPresence_args where 
  arbitrary = M.liftM TimPresence_args (QC.arbitrary)
  shrink obj | obj == default_TimPresence_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimPresence_args{timPresence_args_pbean = timPresence_args_pbean obj} then P.Nothing else P.Just $ default_TimPresence_args{timPresence_args_pbean = timPresence_args_pbean obj}
    ]
from_TimPresence_args :: TimPresence_args -> T.ThriftVal
from_TimPresence_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v490 -> P.Just (1, ("pbean",from_TimPBean _v490))) $ timPresence_args_pbean record
  ]
write_TimPresence_args :: (T.Protocol p, T.Transport t) => p t -> TimPresence_args -> P.IO ()
write_TimPresence_args oprot record = T.writeVal oprot $ from_TimPresence_args record
encode_TimPresence_args :: (T.Protocol p, T.Transport t) => p t -> TimPresence_args -> LBS.ByteString
encode_TimPresence_args oprot record = T.serializeVal oprot $ from_TimPresence_args record
to_TimPresence_args :: T.ThriftVal -> TimPresence_args
to_TimPresence_args (T.TStruct fields) = TimPresence_args{
  timPresence_args_pbean = P.maybe (timPresence_args_pbean default_TimPresence_args) (\(_,_val492) -> (case _val492 of {T.TStruct _val493 -> (to_TimPBean (T.TStruct _val493)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_TimPresence_args _ = P.error "not a struct"
read_TimPresence_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimPresence_args
read_TimPresence_args iprot = to_TimPresence_args <$> T.readVal iprot (T.T_STRUCT typemap_TimPresence_args)
decode_TimPresence_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimPresence_args
decode_TimPresence_args iprot bs = to_TimPresence_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimPresence_args) bs
typemap_TimPresence_args :: T.TypeMap
typemap_TimPresence_args = Map.fromList [(1,("pbean",(T.T_STRUCT typemap_TimPBean)))]
default_TimPresence_args :: TimPresence_args
default_TimPresence_args = TimPresence_args{
  timPresence_args_pbean = default_TimPBean}
data TimPresence_result = TimPresence_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimPresence_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimPresence_result where 
  arbitrary = QC.elements [TimPresence_result]
from_TimPresence_result :: TimPresence_result -> T.ThriftVal
from_TimPresence_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimPresence_result :: (T.Protocol p, T.Transport t) => p t -> TimPresence_result -> P.IO ()
write_TimPresence_result oprot record = T.writeVal oprot $ from_TimPresence_result record
encode_TimPresence_result :: (T.Protocol p, T.Transport t) => p t -> TimPresence_result -> LBS.ByteString
encode_TimPresence_result oprot record = T.serializeVal oprot $ from_TimPresence_result record
to_TimPresence_result :: T.ThriftVal -> TimPresence_result
to_TimPresence_result (T.TStruct fields) = TimPresence_result{

  }
to_TimPresence_result _ = P.error "not a struct"
read_TimPresence_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimPresence_result
read_TimPresence_result iprot = to_TimPresence_result <$> T.readVal iprot (T.T_STRUCT typemap_TimPresence_result)
decode_TimPresence_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimPresence_result
decode_TimPresence_result iprot bs = to_TimPresence_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimPresence_result) bs
typemap_TimPresence_result :: T.TypeMap
typemap_TimPresence_result = Map.fromList []
default_TimPresence_result :: TimPresence_result
default_TimPresence_result = TimPresence_result{
}
data TimMessage_args = TimMessage_args  { timMessage_args_mbean :: TimMBean
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timMessage_args_mbean record  
instance QC.Arbitrary TimMessage_args where 
  arbitrary = M.liftM TimMessage_args (QC.arbitrary)
  shrink obj | obj == default_TimMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimMessage_args{timMessage_args_mbean = timMessage_args_mbean obj} then P.Nothing else P.Just $ default_TimMessage_args{timMessage_args_mbean = timMessage_args_mbean obj}
    ]
from_TimMessage_args :: TimMessage_args -> T.ThriftVal
from_TimMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v501 -> P.Just (1, ("mbean",from_TimMBean _v501))) $ timMessage_args_mbean record
  ]
write_TimMessage_args :: (T.Protocol p, T.Transport t) => p t -> TimMessage_args -> P.IO ()
write_TimMessage_args oprot record = T.writeVal oprot $ from_TimMessage_args record
encode_TimMessage_args :: (T.Protocol p, T.Transport t) => p t -> TimMessage_args -> LBS.ByteString
encode_TimMessage_args oprot record = T.serializeVal oprot $ from_TimMessage_args record
to_TimMessage_args :: T.ThriftVal -> TimMessage_args
to_TimMessage_args (T.TStruct fields) = TimMessage_args{
  timMessage_args_mbean = P.maybe (timMessage_args_mbean default_TimMessage_args) (\(_,_val503) -> (case _val503 of {T.TStruct _val504 -> (to_TimMBean (T.TStruct _val504)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_TimMessage_args _ = P.error "not a struct"
read_TimMessage_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimMessage_args
read_TimMessage_args iprot = to_TimMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_TimMessage_args)
decode_TimMessage_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimMessage_args
decode_TimMessage_args iprot bs = to_TimMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimMessage_args) bs
typemap_TimMessage_args :: T.TypeMap
typemap_TimMessage_args = Map.fromList [(1,("mbean",(T.T_STRUCT typemap_TimMBean)))]
default_TimMessage_args :: TimMessage_args
default_TimMessage_args = TimMessage_args{
  timMessage_args_mbean = default_TimMBean}
data TimMessage_result = TimMessage_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimMessage_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimMessage_result where 
  arbitrary = QC.elements [TimMessage_result]
from_TimMessage_result :: TimMessage_result -> T.ThriftVal
from_TimMessage_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimMessage_result :: (T.Protocol p, T.Transport t) => p t -> TimMessage_result -> P.IO ()
write_TimMessage_result oprot record = T.writeVal oprot $ from_TimMessage_result record
encode_TimMessage_result :: (T.Protocol p, T.Transport t) => p t -> TimMessage_result -> LBS.ByteString
encode_TimMessage_result oprot record = T.serializeVal oprot $ from_TimMessage_result record
to_TimMessage_result :: T.ThriftVal -> TimMessage_result
to_TimMessage_result (T.TStruct fields) = TimMessage_result{

  }
to_TimMessage_result _ = P.error "not a struct"
read_TimMessage_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimMessage_result
read_TimMessage_result iprot = to_TimMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_TimMessage_result)
decode_TimMessage_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimMessage_result
decode_TimMessage_result iprot bs = to_TimMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimMessage_result) bs
typemap_TimMessage_result :: T.TypeMap
typemap_TimMessage_result = Map.fromList []
default_TimMessage_result :: TimMessage_result
default_TimMessage_result = TimMessage_result{
}
data TimPing_args = TimPing_args  { timPing_args_threadId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimPing_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timPing_args_threadId record  
instance QC.Arbitrary TimPing_args where 
  arbitrary = M.liftM TimPing_args (QC.arbitrary)
  shrink obj | obj == default_TimPing_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimPing_args{timPing_args_threadId = timPing_args_threadId obj} then P.Nothing else P.Just $ default_TimPing_args{timPing_args_threadId = timPing_args_threadId obj}
    ]
from_TimPing_args :: TimPing_args -> T.ThriftVal
from_TimPing_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v512 -> P.Just (1, ("threadId",T.TString $ E.encodeUtf8 _v512))) $ timPing_args_threadId record
  ]
write_TimPing_args :: (T.Protocol p, T.Transport t) => p t -> TimPing_args -> P.IO ()
write_TimPing_args oprot record = T.writeVal oprot $ from_TimPing_args record
encode_TimPing_args :: (T.Protocol p, T.Transport t) => p t -> TimPing_args -> LBS.ByteString
encode_TimPing_args oprot record = T.serializeVal oprot $ from_TimPing_args record
to_TimPing_args :: T.ThriftVal -> TimPing_args
to_TimPing_args (T.TStruct fields) = TimPing_args{
  timPing_args_threadId = P.maybe (timPing_args_threadId default_TimPing_args) (\(_,_val514) -> (case _val514 of {T.TString _val515 -> E.decodeUtf8 _val515; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_TimPing_args _ = P.error "not a struct"
read_TimPing_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimPing_args
read_TimPing_args iprot = to_TimPing_args <$> T.readVal iprot (T.T_STRUCT typemap_TimPing_args)
decode_TimPing_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimPing_args
decode_TimPing_args iprot bs = to_TimPing_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimPing_args) bs
typemap_TimPing_args :: T.TypeMap
typemap_TimPing_args = Map.fromList [(1,("threadId",T.T_STRING))]
default_TimPing_args :: TimPing_args
default_TimPing_args = TimPing_args{
  timPing_args_threadId = ""}
data TimPing_result = TimPing_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimPing_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimPing_result where 
  arbitrary = QC.elements [TimPing_result]
from_TimPing_result :: TimPing_result -> T.ThriftVal
from_TimPing_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimPing_result :: (T.Protocol p, T.Transport t) => p t -> TimPing_result -> P.IO ()
write_TimPing_result oprot record = T.writeVal oprot $ from_TimPing_result record
encode_TimPing_result :: (T.Protocol p, T.Transport t) => p t -> TimPing_result -> LBS.ByteString
encode_TimPing_result oprot record = T.serializeVal oprot $ from_TimPing_result record
to_TimPing_result :: T.ThriftVal -> TimPing_result
to_TimPing_result (T.TStruct fields) = TimPing_result{

  }
to_TimPing_result _ = P.error "not a struct"
read_TimPing_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimPing_result
read_TimPing_result iprot = to_TimPing_result <$> T.readVal iprot (T.T_STRUCT typemap_TimPing_result)
decode_TimPing_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimPing_result
decode_TimPing_result iprot bs = to_TimPing_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimPing_result) bs
typemap_TimPing_result :: T.TypeMap
typemap_TimPing_result = Map.fromList []
default_TimPing_result :: TimPing_result
default_TimPing_result = TimPing_result{
}
data TimError_args = TimError_args  { timError_args_e :: TimError
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimError_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timError_args_e record  
instance QC.Arbitrary TimError_args where 
  arbitrary = M.liftM TimError_args (QC.arbitrary)
  shrink obj | obj == default_TimError_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimError_args{timError_args_e = timError_args_e obj} then P.Nothing else P.Just $ default_TimError_args{timError_args_e = timError_args_e obj}
    ]
from_TimError_args :: TimError_args -> T.ThriftVal
from_TimError_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v523 -> P.Just (1, ("e",from_TimError _v523))) $ timError_args_e record
  ]
write_TimError_args :: (T.Protocol p, T.Transport t) => p t -> TimError_args -> P.IO ()
write_TimError_args oprot record = T.writeVal oprot $ from_TimError_args record
encode_TimError_args :: (T.Protocol p, T.Transport t) => p t -> TimError_args -> LBS.ByteString
encode_TimError_args oprot record = T.serializeVal oprot $ from_TimError_args record
to_TimError_args :: T.ThriftVal -> TimError_args
to_TimError_args (T.TStruct fields) = TimError_args{
  timError_args_e = P.maybe (timError_args_e default_TimError_args) (\(_,_val525) -> (case _val525 of {T.TStruct _val526 -> (to_TimError (T.TStruct _val526)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_TimError_args _ = P.error "not a struct"
read_TimError_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimError_args
read_TimError_args iprot = to_TimError_args <$> T.readVal iprot (T.T_STRUCT typemap_TimError_args)
decode_TimError_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimError_args
decode_TimError_args iprot bs = to_TimError_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimError_args) bs
typemap_TimError_args :: T.TypeMap
typemap_TimError_args = Map.fromList [(1,("e",(T.T_STRUCT typemap_TimError)))]
default_TimError_args :: TimError_args
default_TimError_args = TimError_args{
  timError_args_e = default_TimError}
data TimError_result = TimError_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimError_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimError_result where 
  arbitrary = QC.elements [TimError_result]
from_TimError_result :: TimError_result -> T.ThriftVal
from_TimError_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimError_result :: (T.Protocol p, T.Transport t) => p t -> TimError_result -> P.IO ()
write_TimError_result oprot record = T.writeVal oprot $ from_TimError_result record
encode_TimError_result :: (T.Protocol p, T.Transport t) => p t -> TimError_result -> LBS.ByteString
encode_TimError_result oprot record = T.serializeVal oprot $ from_TimError_result record
to_TimError_result :: T.ThriftVal -> TimError_result
to_TimError_result (T.TStruct fields) = TimError_result{

  }
to_TimError_result _ = P.error "not a struct"
read_TimError_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimError_result
read_TimError_result iprot = to_TimError_result <$> T.readVal iprot (T.T_STRUCT typemap_TimError_result)
decode_TimError_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimError_result
decode_TimError_result iprot bs = to_TimError_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimError_result) bs
typemap_TimError_result :: T.TypeMap
typemap_TimError_result = Map.fromList []
default_TimError_result :: TimError_result
default_TimError_result = TimError_result{
}
data TimLogout_args = TimLogout_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimLogout_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimLogout_args where 
  arbitrary = QC.elements [TimLogout_args]
from_TimLogout_args :: TimLogout_args -> T.ThriftVal
from_TimLogout_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimLogout_args :: (T.Protocol p, T.Transport t) => p t -> TimLogout_args -> P.IO ()
write_TimLogout_args oprot record = T.writeVal oprot $ from_TimLogout_args record
encode_TimLogout_args :: (T.Protocol p, T.Transport t) => p t -> TimLogout_args -> LBS.ByteString
encode_TimLogout_args oprot record = T.serializeVal oprot $ from_TimLogout_args record
to_TimLogout_args :: T.ThriftVal -> TimLogout_args
to_TimLogout_args (T.TStruct fields) = TimLogout_args{

  }
to_TimLogout_args _ = P.error "not a struct"
read_TimLogout_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimLogout_args
read_TimLogout_args iprot = to_TimLogout_args <$> T.readVal iprot (T.T_STRUCT typemap_TimLogout_args)
decode_TimLogout_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimLogout_args
decode_TimLogout_args iprot bs = to_TimLogout_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimLogout_args) bs
typemap_TimLogout_args :: T.TypeMap
typemap_TimLogout_args = Map.fromList []
default_TimLogout_args :: TimLogout_args
default_TimLogout_args = TimLogout_args{
}
data TimLogout_result = TimLogout_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimLogout_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimLogout_result where 
  arbitrary = QC.elements [TimLogout_result]
from_TimLogout_result :: TimLogout_result -> T.ThriftVal
from_TimLogout_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimLogout_result :: (T.Protocol p, T.Transport t) => p t -> TimLogout_result -> P.IO ()
write_TimLogout_result oprot record = T.writeVal oprot $ from_TimLogout_result record
encode_TimLogout_result :: (T.Protocol p, T.Transport t) => p t -> TimLogout_result -> LBS.ByteString
encode_TimLogout_result oprot record = T.serializeVal oprot $ from_TimLogout_result record
to_TimLogout_result :: T.ThriftVal -> TimLogout_result
to_TimLogout_result (T.TStruct fields) = TimLogout_result{

  }
to_TimLogout_result _ = P.error "not a struct"
read_TimLogout_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimLogout_result
read_TimLogout_result iprot = to_TimLogout_result <$> T.readVal iprot (T.T_STRUCT typemap_TimLogout_result)
decode_TimLogout_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimLogout_result
decode_TimLogout_result iprot bs = to_TimLogout_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimLogout_result) bs
typemap_TimLogout_result :: T.TypeMap
typemap_TimLogout_result = Map.fromList []
default_TimLogout_result :: TimLogout_result
default_TimLogout_result = TimLogout_result{
}
data TimRegist_args = TimRegist_args  { timRegist_args_tid :: Tid
  , timRegist_args_auth :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimRegist_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timRegist_args_tid record   `H.hashWithSalt` timRegist_args_auth record  
instance QC.Arbitrary TimRegist_args where 
  arbitrary = M.liftM TimRegist_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TimRegist_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimRegist_args{timRegist_args_tid = timRegist_args_tid obj} then P.Nothing else P.Just $ default_TimRegist_args{timRegist_args_tid = timRegist_args_tid obj}
    , if obj == default_TimRegist_args{timRegist_args_auth = timRegist_args_auth obj} then P.Nothing else P.Just $ default_TimRegist_args{timRegist_args_auth = timRegist_args_auth obj}
    ]
from_TimRegist_args :: TimRegist_args -> T.ThriftVal
from_TimRegist_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v544 -> P.Just (1, ("tid",from_Tid _v544))) $ timRegist_args_tid record
  , (\_v544 -> P.Just (2, ("auth",T.TString $ E.encodeUtf8 _v544))) $ timRegist_args_auth record
  ]
write_TimRegist_args :: (T.Protocol p, T.Transport t) => p t -> TimRegist_args -> P.IO ()
write_TimRegist_args oprot record = T.writeVal oprot $ from_TimRegist_args record
encode_TimRegist_args :: (T.Protocol p, T.Transport t) => p t -> TimRegist_args -> LBS.ByteString
encode_TimRegist_args oprot record = T.serializeVal oprot $ from_TimRegist_args record
to_TimRegist_args :: T.ThriftVal -> TimRegist_args
to_TimRegist_args (T.TStruct fields) = TimRegist_args{
  timRegist_args_tid = P.maybe (timRegist_args_tid default_TimRegist_args) (\(_,_val546) -> (case _val546 of {T.TStruct _val547 -> (to_Tid (T.TStruct _val547)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timRegist_args_auth = P.maybe (timRegist_args_auth default_TimRegist_args) (\(_,_val546) -> (case _val546 of {T.TString _val548 -> E.decodeUtf8 _val548; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TimRegist_args _ = P.error "not a struct"
read_TimRegist_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimRegist_args
read_TimRegist_args iprot = to_TimRegist_args <$> T.readVal iprot (T.T_STRUCT typemap_TimRegist_args)
decode_TimRegist_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimRegist_args
decode_TimRegist_args iprot bs = to_TimRegist_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimRegist_args) bs
typemap_TimRegist_args :: T.TypeMap
typemap_TimRegist_args = Map.fromList [(1,("tid",(T.T_STRUCT typemap_Tid))),(2,("auth",T.T_STRING))]
default_TimRegist_args :: TimRegist_args
default_TimRegist_args = TimRegist_args{
  timRegist_args_tid = default_Tid,
  timRegist_args_auth = ""}
data TimRegist_result = TimRegist_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimRegist_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimRegist_result where 
  arbitrary = QC.elements [TimRegist_result]
from_TimRegist_result :: TimRegist_result -> T.ThriftVal
from_TimRegist_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimRegist_result :: (T.Protocol p, T.Transport t) => p t -> TimRegist_result -> P.IO ()
write_TimRegist_result oprot record = T.writeVal oprot $ from_TimRegist_result record
encode_TimRegist_result :: (T.Protocol p, T.Transport t) => p t -> TimRegist_result -> LBS.ByteString
encode_TimRegist_result oprot record = T.serializeVal oprot $ from_TimRegist_result record
to_TimRegist_result :: T.ThriftVal -> TimRegist_result
to_TimRegist_result (T.TStruct fields) = TimRegist_result{

  }
to_TimRegist_result _ = P.error "not a struct"
read_TimRegist_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimRegist_result
read_TimRegist_result iprot = to_TimRegist_result <$> T.readVal iprot (T.T_STRUCT typemap_TimRegist_result)
decode_TimRegist_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimRegist_result
decode_TimRegist_result iprot bs = to_TimRegist_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimRegist_result) bs
typemap_TimRegist_result :: T.TypeMap
typemap_TimRegist_result = Map.fromList []
default_TimRegist_result :: TimRegist_result
default_TimRegist_result = TimRegist_result{
}
data TimRoser_args = TimRoser_args  { timRoser_args_roster :: TimRoster
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimRoser_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timRoser_args_roster record  
instance QC.Arbitrary TimRoser_args where 
  arbitrary = M.liftM TimRoser_args (QC.arbitrary)
  shrink obj | obj == default_TimRoser_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimRoser_args{timRoser_args_roster = timRoser_args_roster obj} then P.Nothing else P.Just $ default_TimRoser_args{timRoser_args_roster = timRoser_args_roster obj}
    ]
from_TimRoser_args :: TimRoser_args -> T.ThriftVal
from_TimRoser_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v556 -> P.Just (1, ("roster",from_TimRoster _v556))) $ timRoser_args_roster record
  ]
write_TimRoser_args :: (T.Protocol p, T.Transport t) => p t -> TimRoser_args -> P.IO ()
write_TimRoser_args oprot record = T.writeVal oprot $ from_TimRoser_args record
encode_TimRoser_args :: (T.Protocol p, T.Transport t) => p t -> TimRoser_args -> LBS.ByteString
encode_TimRoser_args oprot record = T.serializeVal oprot $ from_TimRoser_args record
to_TimRoser_args :: T.ThriftVal -> TimRoser_args
to_TimRoser_args (T.TStruct fields) = TimRoser_args{
  timRoser_args_roster = P.maybe (timRoser_args_roster default_TimRoser_args) (\(_,_val558) -> (case _val558 of {T.TStruct _val559 -> (to_TimRoster (T.TStruct _val559)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_TimRoser_args _ = P.error "not a struct"
read_TimRoser_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimRoser_args
read_TimRoser_args iprot = to_TimRoser_args <$> T.readVal iprot (T.T_STRUCT typemap_TimRoser_args)
decode_TimRoser_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimRoser_args
decode_TimRoser_args iprot bs = to_TimRoser_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimRoser_args) bs
typemap_TimRoser_args :: T.TypeMap
typemap_TimRoser_args = Map.fromList [(1,("roster",(T.T_STRUCT typemap_TimRoster)))]
default_TimRoser_args :: TimRoser_args
default_TimRoser_args = TimRoser_args{
  timRoser_args_roster = default_TimRoster}
data TimRoser_result = TimRoser_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimRoser_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimRoser_result where 
  arbitrary = QC.elements [TimRoser_result]
from_TimRoser_result :: TimRoser_result -> T.ThriftVal
from_TimRoser_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimRoser_result :: (T.Protocol p, T.Transport t) => p t -> TimRoser_result -> P.IO ()
write_TimRoser_result oprot record = T.writeVal oprot $ from_TimRoser_result record
encode_TimRoser_result :: (T.Protocol p, T.Transport t) => p t -> TimRoser_result -> LBS.ByteString
encode_TimRoser_result oprot record = T.serializeVal oprot $ from_TimRoser_result record
to_TimRoser_result :: T.ThriftVal -> TimRoser_result
to_TimRoser_result (T.TStruct fields) = TimRoser_result{

  }
to_TimRoser_result _ = P.error "not a struct"
read_TimRoser_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimRoser_result
read_TimRoser_result iprot = to_TimRoser_result <$> T.readVal iprot (T.T_STRUCT typemap_TimRoser_result)
decode_TimRoser_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimRoser_result
decode_TimRoser_result iprot bs = to_TimRoser_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimRoser_result) bs
typemap_TimRoser_result :: T.TypeMap
typemap_TimRoser_result = Map.fromList []
default_TimRoser_result :: TimRoser_result
default_TimRoser_result = TimRoser_result{
}
data TimMessageList_args = TimMessageList_args  { timMessageList_args_mbeanList :: TimMBeanList
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimMessageList_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timMessageList_args_mbeanList record  
instance QC.Arbitrary TimMessageList_args where 
  arbitrary = M.liftM TimMessageList_args (QC.arbitrary)
  shrink obj | obj == default_TimMessageList_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimMessageList_args{timMessageList_args_mbeanList = timMessageList_args_mbeanList obj} then P.Nothing else P.Just $ default_TimMessageList_args{timMessageList_args_mbeanList = timMessageList_args_mbeanList obj}
    ]
from_TimMessageList_args :: TimMessageList_args -> T.ThriftVal
from_TimMessageList_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v567 -> P.Just (1, ("mbeanList",from_TimMBeanList _v567))) $ timMessageList_args_mbeanList record
  ]
write_TimMessageList_args :: (T.Protocol p, T.Transport t) => p t -> TimMessageList_args -> P.IO ()
write_TimMessageList_args oprot record = T.writeVal oprot $ from_TimMessageList_args record
encode_TimMessageList_args :: (T.Protocol p, T.Transport t) => p t -> TimMessageList_args -> LBS.ByteString
encode_TimMessageList_args oprot record = T.serializeVal oprot $ from_TimMessageList_args record
to_TimMessageList_args :: T.ThriftVal -> TimMessageList_args
to_TimMessageList_args (T.TStruct fields) = TimMessageList_args{
  timMessageList_args_mbeanList = P.maybe (timMessageList_args_mbeanList default_TimMessageList_args) (\(_,_val569) -> (case _val569 of {T.TStruct _val570 -> (to_TimMBeanList (T.TStruct _val570)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_TimMessageList_args _ = P.error "not a struct"
read_TimMessageList_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimMessageList_args
read_TimMessageList_args iprot = to_TimMessageList_args <$> T.readVal iprot (T.T_STRUCT typemap_TimMessageList_args)
decode_TimMessageList_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimMessageList_args
decode_TimMessageList_args iprot bs = to_TimMessageList_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimMessageList_args) bs
typemap_TimMessageList_args :: T.TypeMap
typemap_TimMessageList_args = Map.fromList [(1,("mbeanList",(T.T_STRUCT typemap_TimMBeanList)))]
default_TimMessageList_args :: TimMessageList_args
default_TimMessageList_args = TimMessageList_args{
  timMessageList_args_mbeanList = default_TimMBeanList}
data TimMessageList_result = TimMessageList_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimMessageList_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimMessageList_result where 
  arbitrary = QC.elements [TimMessageList_result]
from_TimMessageList_result :: TimMessageList_result -> T.ThriftVal
from_TimMessageList_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimMessageList_result :: (T.Protocol p, T.Transport t) => p t -> TimMessageList_result -> P.IO ()
write_TimMessageList_result oprot record = T.writeVal oprot $ from_TimMessageList_result record
encode_TimMessageList_result :: (T.Protocol p, T.Transport t) => p t -> TimMessageList_result -> LBS.ByteString
encode_TimMessageList_result oprot record = T.serializeVal oprot $ from_TimMessageList_result record
to_TimMessageList_result :: T.ThriftVal -> TimMessageList_result
to_TimMessageList_result (T.TStruct fields) = TimMessageList_result{

  }
to_TimMessageList_result _ = P.error "not a struct"
read_TimMessageList_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimMessageList_result
read_TimMessageList_result iprot = to_TimMessageList_result <$> T.readVal iprot (T.T_STRUCT typemap_TimMessageList_result)
decode_TimMessageList_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimMessageList_result
decode_TimMessageList_result iprot bs = to_TimMessageList_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimMessageList_result) bs
typemap_TimMessageList_result :: T.TypeMap
typemap_TimMessageList_result = Map.fromList []
default_TimMessageList_result :: TimMessageList_result
default_TimMessageList_result = TimMessageList_result{
}
data TimPresenceList_args = TimPresenceList_args  { timPresenceList_args_pbeanList :: TimPBeanList
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimPresenceList_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timPresenceList_args_pbeanList record  
instance QC.Arbitrary TimPresenceList_args where 
  arbitrary = M.liftM TimPresenceList_args (QC.arbitrary)
  shrink obj | obj == default_TimPresenceList_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimPresenceList_args{timPresenceList_args_pbeanList = timPresenceList_args_pbeanList obj} then P.Nothing else P.Just $ default_TimPresenceList_args{timPresenceList_args_pbeanList = timPresenceList_args_pbeanList obj}
    ]
from_TimPresenceList_args :: TimPresenceList_args -> T.ThriftVal
from_TimPresenceList_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v578 -> P.Just (1, ("pbeanList",from_TimPBeanList _v578))) $ timPresenceList_args_pbeanList record
  ]
write_TimPresenceList_args :: (T.Protocol p, T.Transport t) => p t -> TimPresenceList_args -> P.IO ()
write_TimPresenceList_args oprot record = T.writeVal oprot $ from_TimPresenceList_args record
encode_TimPresenceList_args :: (T.Protocol p, T.Transport t) => p t -> TimPresenceList_args -> LBS.ByteString
encode_TimPresenceList_args oprot record = T.serializeVal oprot $ from_TimPresenceList_args record
to_TimPresenceList_args :: T.ThriftVal -> TimPresenceList_args
to_TimPresenceList_args (T.TStruct fields) = TimPresenceList_args{
  timPresenceList_args_pbeanList = P.maybe (timPresenceList_args_pbeanList default_TimPresenceList_args) (\(_,_val580) -> (case _val580 of {T.TStruct _val581 -> (to_TimPBeanList (T.TStruct _val581)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_TimPresenceList_args _ = P.error "not a struct"
read_TimPresenceList_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimPresenceList_args
read_TimPresenceList_args iprot = to_TimPresenceList_args <$> T.readVal iprot (T.T_STRUCT typemap_TimPresenceList_args)
decode_TimPresenceList_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimPresenceList_args
decode_TimPresenceList_args iprot bs = to_TimPresenceList_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimPresenceList_args) bs
typemap_TimPresenceList_args :: T.TypeMap
typemap_TimPresenceList_args = Map.fromList [(1,("pbeanList",(T.T_STRUCT typemap_TimPBeanList)))]
default_TimPresenceList_args :: TimPresenceList_args
default_TimPresenceList_args = TimPresenceList_args{
  timPresenceList_args_pbeanList = default_TimPBeanList}
data TimPresenceList_result = TimPresenceList_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimPresenceList_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimPresenceList_result where 
  arbitrary = QC.elements [TimPresenceList_result]
from_TimPresenceList_result :: TimPresenceList_result -> T.ThriftVal
from_TimPresenceList_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimPresenceList_result :: (T.Protocol p, T.Transport t) => p t -> TimPresenceList_result -> P.IO ()
write_TimPresenceList_result oprot record = T.writeVal oprot $ from_TimPresenceList_result record
encode_TimPresenceList_result :: (T.Protocol p, T.Transport t) => p t -> TimPresenceList_result -> LBS.ByteString
encode_TimPresenceList_result oprot record = T.serializeVal oprot $ from_TimPresenceList_result record
to_TimPresenceList_result :: T.ThriftVal -> TimPresenceList_result
to_TimPresenceList_result (T.TStruct fields) = TimPresenceList_result{

  }
to_TimPresenceList_result _ = P.error "not a struct"
read_TimPresenceList_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimPresenceList_result
read_TimPresenceList_result iprot = to_TimPresenceList_result <$> T.readVal iprot (T.T_STRUCT typemap_TimPresenceList_result)
decode_TimPresenceList_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimPresenceList_result
decode_TimPresenceList_result iprot bs = to_TimPresenceList_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimPresenceList_result) bs
typemap_TimPresenceList_result :: T.TypeMap
typemap_TimPresenceList_result = Map.fromList []
default_TimPresenceList_result :: TimPresenceList_result
default_TimPresenceList_result = TimPresenceList_result{
}
data TimMessageIq_args = TimMessageIq_args  { timMessageIq_args_timMsgIq :: TimMessageIq
  , timMessageIq_args_iqType :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimMessageIq_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timMessageIq_args_timMsgIq record   `H.hashWithSalt` timMessageIq_args_iqType record  
instance QC.Arbitrary TimMessageIq_args where 
  arbitrary = M.liftM TimMessageIq_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TimMessageIq_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimMessageIq_args{timMessageIq_args_timMsgIq = timMessageIq_args_timMsgIq obj} then P.Nothing else P.Just $ default_TimMessageIq_args{timMessageIq_args_timMsgIq = timMessageIq_args_timMsgIq obj}
    , if obj == default_TimMessageIq_args{timMessageIq_args_iqType = timMessageIq_args_iqType obj} then P.Nothing else P.Just $ default_TimMessageIq_args{timMessageIq_args_iqType = timMessageIq_args_iqType obj}
    ]
from_TimMessageIq_args :: TimMessageIq_args -> T.ThriftVal
from_TimMessageIq_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v589 -> P.Just (1, ("timMsgIq",from_TimMessageIq _v589))) $ timMessageIq_args_timMsgIq record
  , (\_v589 -> P.Just (2, ("iqType",T.TString $ E.encodeUtf8 _v589))) $ timMessageIq_args_iqType record
  ]
write_TimMessageIq_args :: (T.Protocol p, T.Transport t) => p t -> TimMessageIq_args -> P.IO ()
write_TimMessageIq_args oprot record = T.writeVal oprot $ from_TimMessageIq_args record
encode_TimMessageIq_args :: (T.Protocol p, T.Transport t) => p t -> TimMessageIq_args -> LBS.ByteString
encode_TimMessageIq_args oprot record = T.serializeVal oprot $ from_TimMessageIq_args record
to_TimMessageIq_args :: T.ThriftVal -> TimMessageIq_args
to_TimMessageIq_args (T.TStruct fields) = TimMessageIq_args{
  timMessageIq_args_timMsgIq = P.maybe (timMessageIq_args_timMsgIq default_TimMessageIq_args) (\(_,_val591) -> (case _val591 of {T.TStruct _val592 -> (to_TimMessageIq (T.TStruct _val592)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timMessageIq_args_iqType = P.maybe (timMessageIq_args_iqType default_TimMessageIq_args) (\(_,_val591) -> (case _val591 of {T.TString _val593 -> E.decodeUtf8 _val593; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TimMessageIq_args _ = P.error "not a struct"
read_TimMessageIq_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimMessageIq_args
read_TimMessageIq_args iprot = to_TimMessageIq_args <$> T.readVal iprot (T.T_STRUCT typemap_TimMessageIq_args)
decode_TimMessageIq_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimMessageIq_args
decode_TimMessageIq_args iprot bs = to_TimMessageIq_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimMessageIq_args) bs
typemap_TimMessageIq_args :: T.TypeMap
typemap_TimMessageIq_args = Map.fromList [(1,("timMsgIq",(T.T_STRUCT typemap_TimMessageIq))),(2,("iqType",T.T_STRING))]
default_TimMessageIq_args :: TimMessageIq_args
default_TimMessageIq_args = TimMessageIq_args{
  timMessageIq_args_timMsgIq = default_TimMessageIq,
  timMessageIq_args_iqType = ""}
data TimMessageIq_result = TimMessageIq_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimMessageIq_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimMessageIq_result where 
  arbitrary = QC.elements [TimMessageIq_result]
from_TimMessageIq_result :: TimMessageIq_result -> T.ThriftVal
from_TimMessageIq_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimMessageIq_result :: (T.Protocol p, T.Transport t) => p t -> TimMessageIq_result -> P.IO ()
write_TimMessageIq_result oprot record = T.writeVal oprot $ from_TimMessageIq_result record
encode_TimMessageIq_result :: (T.Protocol p, T.Transport t) => p t -> TimMessageIq_result -> LBS.ByteString
encode_TimMessageIq_result oprot record = T.serializeVal oprot $ from_TimMessageIq_result record
to_TimMessageIq_result :: T.ThriftVal -> TimMessageIq_result
to_TimMessageIq_result (T.TStruct fields) = TimMessageIq_result{

  }
to_TimMessageIq_result _ = P.error "not a struct"
read_TimMessageIq_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimMessageIq_result
read_TimMessageIq_result iprot = to_TimMessageIq_result <$> T.readVal iprot (T.T_STRUCT typemap_TimMessageIq_result)
decode_TimMessageIq_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimMessageIq_result
decode_TimMessageIq_result iprot bs = to_TimMessageIq_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimMessageIq_result) bs
typemap_TimMessageIq_result :: T.TypeMap
typemap_TimMessageIq_result = Map.fromList []
default_TimMessageIq_result :: TimMessageIq_result
default_TimMessageIq_result = TimMessageIq_result{
}
data TimMessageResult_args = TimMessageResult_args  { timMessageResult_args_mbean :: TimMBean
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimMessageResult_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timMessageResult_args_mbean record  
instance QC.Arbitrary TimMessageResult_args where 
  arbitrary = M.liftM TimMessageResult_args (QC.arbitrary)
  shrink obj | obj == default_TimMessageResult_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimMessageResult_args{timMessageResult_args_mbean = timMessageResult_args_mbean obj} then P.Nothing else P.Just $ default_TimMessageResult_args{timMessageResult_args_mbean = timMessageResult_args_mbean obj}
    ]
from_TimMessageResult_args :: TimMessageResult_args -> T.ThriftVal
from_TimMessageResult_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v601 -> P.Just (1, ("mbean",from_TimMBean _v601))) $ timMessageResult_args_mbean record
  ]
write_TimMessageResult_args :: (T.Protocol p, T.Transport t) => p t -> TimMessageResult_args -> P.IO ()
write_TimMessageResult_args oprot record = T.writeVal oprot $ from_TimMessageResult_args record
encode_TimMessageResult_args :: (T.Protocol p, T.Transport t) => p t -> TimMessageResult_args -> LBS.ByteString
encode_TimMessageResult_args oprot record = T.serializeVal oprot $ from_TimMessageResult_args record
to_TimMessageResult_args :: T.ThriftVal -> TimMessageResult_args
to_TimMessageResult_args (T.TStruct fields) = TimMessageResult_args{
  timMessageResult_args_mbean = P.maybe (timMessageResult_args_mbean default_TimMessageResult_args) (\(_,_val603) -> (case _val603 of {T.TStruct _val604 -> (to_TimMBean (T.TStruct _val604)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_TimMessageResult_args _ = P.error "not a struct"
read_TimMessageResult_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimMessageResult_args
read_TimMessageResult_args iprot = to_TimMessageResult_args <$> T.readVal iprot (T.T_STRUCT typemap_TimMessageResult_args)
decode_TimMessageResult_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimMessageResult_args
decode_TimMessageResult_args iprot bs = to_TimMessageResult_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimMessageResult_args) bs
typemap_TimMessageResult_args :: T.TypeMap
typemap_TimMessageResult_args = Map.fromList [(1,("mbean",(T.T_STRUCT typemap_TimMBean)))]
default_TimMessageResult_args :: TimMessageResult_args
default_TimMessageResult_args = TimMessageResult_args{
  timMessageResult_args_mbean = default_TimMBean}
data TimMessageResult_result = TimMessageResult_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimMessageResult_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimMessageResult_result where 
  arbitrary = QC.elements [TimMessageResult_result]
from_TimMessageResult_result :: TimMessageResult_result -> T.ThriftVal
from_TimMessageResult_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimMessageResult_result :: (T.Protocol p, T.Transport t) => p t -> TimMessageResult_result -> P.IO ()
write_TimMessageResult_result oprot record = T.writeVal oprot $ from_TimMessageResult_result record
encode_TimMessageResult_result :: (T.Protocol p, T.Transport t) => p t -> TimMessageResult_result -> LBS.ByteString
encode_TimMessageResult_result oprot record = T.serializeVal oprot $ from_TimMessageResult_result record
to_TimMessageResult_result :: T.ThriftVal -> TimMessageResult_result
to_TimMessageResult_result (T.TStruct fields) = TimMessageResult_result{

  }
to_TimMessageResult_result _ = P.error "not a struct"
read_TimMessageResult_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimMessageResult_result
read_TimMessageResult_result iprot = to_TimMessageResult_result <$> T.readVal iprot (T.T_STRUCT typemap_TimMessageResult_result)
decode_TimMessageResult_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimMessageResult_result
decode_TimMessageResult_result iprot bs = to_TimMessageResult_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimMessageResult_result) bs
typemap_TimMessageResult_result :: T.TypeMap
typemap_TimMessageResult_result = Map.fromList []
default_TimMessageResult_result :: TimMessageResult_result
default_TimMessageResult_result = TimMessageResult_result{
}
data TimProperty_args = TimProperty_args  { timProperty_args_tpb :: TimPropertyBean
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimProperty_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timProperty_args_tpb record  
instance QC.Arbitrary TimProperty_args where 
  arbitrary = M.liftM TimProperty_args (QC.arbitrary)
  shrink obj | obj == default_TimProperty_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimProperty_args{timProperty_args_tpb = timProperty_args_tpb obj} then P.Nothing else P.Just $ default_TimProperty_args{timProperty_args_tpb = timProperty_args_tpb obj}
    ]
from_TimProperty_args :: TimProperty_args -> T.ThriftVal
from_TimProperty_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v612 -> P.Just (1, ("tpb",from_TimPropertyBean _v612))) $ timProperty_args_tpb record
  ]
write_TimProperty_args :: (T.Protocol p, T.Transport t) => p t -> TimProperty_args -> P.IO ()
write_TimProperty_args oprot record = T.writeVal oprot $ from_TimProperty_args record
encode_TimProperty_args :: (T.Protocol p, T.Transport t) => p t -> TimProperty_args -> LBS.ByteString
encode_TimProperty_args oprot record = T.serializeVal oprot $ from_TimProperty_args record
to_TimProperty_args :: T.ThriftVal -> TimProperty_args
to_TimProperty_args (T.TStruct fields) = TimProperty_args{
  timProperty_args_tpb = P.maybe (timProperty_args_tpb default_TimProperty_args) (\(_,_val614) -> (case _val614 of {T.TStruct _val615 -> (to_TimPropertyBean (T.TStruct _val615)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_TimProperty_args _ = P.error "not a struct"
read_TimProperty_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimProperty_args
read_TimProperty_args iprot = to_TimProperty_args <$> T.readVal iprot (T.T_STRUCT typemap_TimProperty_args)
decode_TimProperty_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimProperty_args
decode_TimProperty_args iprot bs = to_TimProperty_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimProperty_args) bs
typemap_TimProperty_args :: T.TypeMap
typemap_TimProperty_args = Map.fromList [(1,("tpb",(T.T_STRUCT typemap_TimPropertyBean)))]
default_TimProperty_args :: TimProperty_args
default_TimProperty_args = TimProperty_args{
  timProperty_args_tpb = default_TimPropertyBean}
data TimProperty_result = TimProperty_result deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimProperty_result where
  hashWithSalt salt record = salt  
instance QC.Arbitrary TimProperty_result where 
  arbitrary = QC.elements [TimProperty_result]
from_TimProperty_result :: TimProperty_result -> T.ThriftVal
from_TimProperty_result record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_TimProperty_result :: (T.Protocol p, T.Transport t) => p t -> TimProperty_result -> P.IO ()
write_TimProperty_result oprot record = T.writeVal oprot $ from_TimProperty_result record
encode_TimProperty_result :: (T.Protocol p, T.Transport t) => p t -> TimProperty_result -> LBS.ByteString
encode_TimProperty_result oprot record = T.serializeVal oprot $ from_TimProperty_result record
to_TimProperty_result :: T.ThriftVal -> TimProperty_result
to_TimProperty_result (T.TStruct fields) = TimProperty_result{

  }
to_TimProperty_result _ = P.error "not a struct"
read_TimProperty_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimProperty_result
read_TimProperty_result iprot = to_TimProperty_result <$> T.readVal iprot (T.T_STRUCT typemap_TimProperty_result)
decode_TimProperty_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimProperty_result
decode_TimProperty_result iprot bs = to_TimProperty_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimProperty_result) bs
typemap_TimProperty_result :: T.TypeMap
typemap_TimProperty_result = Map.fromList []
default_TimProperty_result :: TimProperty_result
default_TimProperty_result = TimProperty_result{
}
data TimRemoteUserAuth_args = TimRemoteUserAuth_args  { timRemoteUserAuth_args_tid :: Tid
  , timRemoteUserAuth_args_pwd :: LT.Text
  , timRemoteUserAuth_args_auth :: TimAuth
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimRemoteUserAuth_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timRemoteUserAuth_args_tid record   `H.hashWithSalt` timRemoteUserAuth_args_pwd record   `H.hashWithSalt` timRemoteUserAuth_args_auth record  
instance QC.Arbitrary TimRemoteUserAuth_args where 
  arbitrary = M.liftM TimRemoteUserAuth_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TimRemoteUserAuth_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimRemoteUserAuth_args{timRemoteUserAuth_args_tid = timRemoteUserAuth_args_tid obj} then P.Nothing else P.Just $ default_TimRemoteUserAuth_args{timRemoteUserAuth_args_tid = timRemoteUserAuth_args_tid obj}
    , if obj == default_TimRemoteUserAuth_args{timRemoteUserAuth_args_pwd = timRemoteUserAuth_args_pwd obj} then P.Nothing else P.Just $ default_TimRemoteUserAuth_args{timRemoteUserAuth_args_pwd = timRemoteUserAuth_args_pwd obj}
    , if obj == default_TimRemoteUserAuth_args{timRemoteUserAuth_args_auth = timRemoteUserAuth_args_auth obj} then P.Nothing else P.Just $ default_TimRemoteUserAuth_args{timRemoteUserAuth_args_auth = timRemoteUserAuth_args_auth obj}
    ]
from_TimRemoteUserAuth_args :: TimRemoteUserAuth_args -> T.ThriftVal
from_TimRemoteUserAuth_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v623 -> P.Just (1, ("tid",from_Tid _v623))) $ timRemoteUserAuth_args_tid record
  , (\_v623 -> P.Just (2, ("pwd",T.TString $ E.encodeUtf8 _v623))) $ timRemoteUserAuth_args_pwd record
  , (\_v623 -> P.Just (3, ("auth",from_TimAuth _v623))) $ timRemoteUserAuth_args_auth record
  ]
write_TimRemoteUserAuth_args :: (T.Protocol p, T.Transport t) => p t -> TimRemoteUserAuth_args -> P.IO ()
write_TimRemoteUserAuth_args oprot record = T.writeVal oprot $ from_TimRemoteUserAuth_args record
encode_TimRemoteUserAuth_args :: (T.Protocol p, T.Transport t) => p t -> TimRemoteUserAuth_args -> LBS.ByteString
encode_TimRemoteUserAuth_args oprot record = T.serializeVal oprot $ from_TimRemoteUserAuth_args record
to_TimRemoteUserAuth_args :: T.ThriftVal -> TimRemoteUserAuth_args
to_TimRemoteUserAuth_args (T.TStruct fields) = TimRemoteUserAuth_args{
  timRemoteUserAuth_args_tid = P.maybe (timRemoteUserAuth_args_tid default_TimRemoteUserAuth_args) (\(_,_val625) -> (case _val625 of {T.TStruct _val626 -> (to_Tid (T.TStruct _val626)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timRemoteUserAuth_args_pwd = P.maybe (timRemoteUserAuth_args_pwd default_TimRemoteUserAuth_args) (\(_,_val625) -> (case _val625 of {T.TString _val627 -> E.decodeUtf8 _val627; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timRemoteUserAuth_args_auth = P.maybe (timRemoteUserAuth_args_auth default_TimRemoteUserAuth_args) (\(_,_val625) -> (case _val625 of {T.TStruct _val628 -> (to_TimAuth (T.TStruct _val628)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_TimRemoteUserAuth_args _ = P.error "not a struct"
read_TimRemoteUserAuth_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimRemoteUserAuth_args
read_TimRemoteUserAuth_args iprot = to_TimRemoteUserAuth_args <$> T.readVal iprot (T.T_STRUCT typemap_TimRemoteUserAuth_args)
decode_TimRemoteUserAuth_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimRemoteUserAuth_args
decode_TimRemoteUserAuth_args iprot bs = to_TimRemoteUserAuth_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimRemoteUserAuth_args) bs
typemap_TimRemoteUserAuth_args :: T.TypeMap
typemap_TimRemoteUserAuth_args = Map.fromList [(1,("tid",(T.T_STRUCT typemap_Tid))),(2,("pwd",T.T_STRING)),(3,("auth",(T.T_STRUCT typemap_TimAuth)))]
default_TimRemoteUserAuth_args :: TimRemoteUserAuth_args
default_TimRemoteUserAuth_args = TimRemoteUserAuth_args{
  timRemoteUserAuth_args_tid = default_Tid,
  timRemoteUserAuth_args_pwd = "",
  timRemoteUserAuth_args_auth = default_TimAuth}
data TimRemoteUserAuth_result = TimRemoteUserAuth_result  { timRemoteUserAuth_result_success :: TimRemoteUserBean
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimRemoteUserAuth_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` timRemoteUserAuth_result_success record  
instance QC.Arbitrary TimRemoteUserAuth_result where 
  arbitrary = M.liftM TimRemoteUserAuth_result (QC.arbitrary)
  shrink obj | obj == default_TimRemoteUserAuth_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimRemoteUserAuth_result{timRemoteUserAuth_result_success = timRemoteUserAuth_result_success obj} then P.Nothing else P.Just $ default_TimRemoteUserAuth_result{timRemoteUserAuth_result_success = timRemoteUserAuth_result_success obj}
    ]
from_TimRemoteUserAuth_result :: TimRemoteUserAuth_result -> T.ThriftVal
from_TimRemoteUserAuth_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v631 -> P.Just (0, ("success",from_TimRemoteUserBean _v631))) $ timRemoteUserAuth_result_success record
  ]
write_TimRemoteUserAuth_result :: (T.Protocol p, T.Transport t) => p t -> TimRemoteUserAuth_result -> P.IO ()
write_TimRemoteUserAuth_result oprot record = T.writeVal oprot $ from_TimRemoteUserAuth_result record
encode_TimRemoteUserAuth_result :: (T.Protocol p, T.Transport t) => p t -> TimRemoteUserAuth_result -> LBS.ByteString
encode_TimRemoteUserAuth_result oprot record = T.serializeVal oprot $ from_TimRemoteUserAuth_result record
to_TimRemoteUserAuth_result :: T.ThriftVal -> TimRemoteUserAuth_result
to_TimRemoteUserAuth_result (T.TStruct fields) = TimRemoteUserAuth_result{
  timRemoteUserAuth_result_success = P.maybe (timRemoteUserAuth_result_success default_TimRemoteUserAuth_result) (\(_,_val633) -> (case _val633 of {T.TStruct _val634 -> (to_TimRemoteUserBean (T.TStruct _val634)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_TimRemoteUserAuth_result _ = P.error "not a struct"
read_TimRemoteUserAuth_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimRemoteUserAuth_result
read_TimRemoteUserAuth_result iprot = to_TimRemoteUserAuth_result <$> T.readVal iprot (T.T_STRUCT typemap_TimRemoteUserAuth_result)
decode_TimRemoteUserAuth_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimRemoteUserAuth_result
decode_TimRemoteUserAuth_result iprot bs = to_TimRemoteUserAuth_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimRemoteUserAuth_result) bs
typemap_TimRemoteUserAuth_result :: T.TypeMap
typemap_TimRemoteUserAuth_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TimRemoteUserBean)))]
default_TimRemoteUserAuth_result :: TimRemoteUserAuth_result
default_TimRemoteUserAuth_result = TimRemoteUserAuth_result{
  timRemoteUserAuth_result_success = default_TimRemoteUserBean}
data TimRemoteUserGet_args = TimRemoteUserGet_args  { timRemoteUserGet_args_tid :: Tid
  , timRemoteUserGet_args_auth :: TimAuth
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimRemoteUserGet_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timRemoteUserGet_args_tid record   `H.hashWithSalt` timRemoteUserGet_args_auth record  
instance QC.Arbitrary TimRemoteUserGet_args where 
  arbitrary = M.liftM TimRemoteUserGet_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TimRemoteUserGet_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimRemoteUserGet_args{timRemoteUserGet_args_tid = timRemoteUserGet_args_tid obj} then P.Nothing else P.Just $ default_TimRemoteUserGet_args{timRemoteUserGet_args_tid = timRemoteUserGet_args_tid obj}
    , if obj == default_TimRemoteUserGet_args{timRemoteUserGet_args_auth = timRemoteUserGet_args_auth obj} then P.Nothing else P.Just $ default_TimRemoteUserGet_args{timRemoteUserGet_args_auth = timRemoteUserGet_args_auth obj}
    ]
from_TimRemoteUserGet_args :: TimRemoteUserGet_args -> T.ThriftVal
from_TimRemoteUserGet_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v637 -> P.Just (1, ("tid",from_Tid _v637))) $ timRemoteUserGet_args_tid record
  , (\_v637 -> P.Just (2, ("auth",from_TimAuth _v637))) $ timRemoteUserGet_args_auth record
  ]
write_TimRemoteUserGet_args :: (T.Protocol p, T.Transport t) => p t -> TimRemoteUserGet_args -> P.IO ()
write_TimRemoteUserGet_args oprot record = T.writeVal oprot $ from_TimRemoteUserGet_args record
encode_TimRemoteUserGet_args :: (T.Protocol p, T.Transport t) => p t -> TimRemoteUserGet_args -> LBS.ByteString
encode_TimRemoteUserGet_args oprot record = T.serializeVal oprot $ from_TimRemoteUserGet_args record
to_TimRemoteUserGet_args :: T.ThriftVal -> TimRemoteUserGet_args
to_TimRemoteUserGet_args (T.TStruct fields) = TimRemoteUserGet_args{
  timRemoteUserGet_args_tid = P.maybe (timRemoteUserGet_args_tid default_TimRemoteUserGet_args) (\(_,_val639) -> (case _val639 of {T.TStruct _val640 -> (to_Tid (T.TStruct _val640)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timRemoteUserGet_args_auth = P.maybe (timRemoteUserGet_args_auth default_TimRemoteUserGet_args) (\(_,_val639) -> (case _val639 of {T.TStruct _val641 -> (to_TimAuth (T.TStruct _val641)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TimRemoteUserGet_args _ = P.error "not a struct"
read_TimRemoteUserGet_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimRemoteUserGet_args
read_TimRemoteUserGet_args iprot = to_TimRemoteUserGet_args <$> T.readVal iprot (T.T_STRUCT typemap_TimRemoteUserGet_args)
decode_TimRemoteUserGet_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimRemoteUserGet_args
decode_TimRemoteUserGet_args iprot bs = to_TimRemoteUserGet_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimRemoteUserGet_args) bs
typemap_TimRemoteUserGet_args :: T.TypeMap
typemap_TimRemoteUserGet_args = Map.fromList [(1,("tid",(T.T_STRUCT typemap_Tid))),(2,("auth",(T.T_STRUCT typemap_TimAuth)))]
default_TimRemoteUserGet_args :: TimRemoteUserGet_args
default_TimRemoteUserGet_args = TimRemoteUserGet_args{
  timRemoteUserGet_args_tid = default_Tid,
  timRemoteUserGet_args_auth = default_TimAuth}
data TimRemoteUserGet_result = TimRemoteUserGet_result  { timRemoteUserGet_result_success :: TimRemoteUserBean
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimRemoteUserGet_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` timRemoteUserGet_result_success record  
instance QC.Arbitrary TimRemoteUserGet_result where 
  arbitrary = M.liftM TimRemoteUserGet_result (QC.arbitrary)
  shrink obj | obj == default_TimRemoteUserGet_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimRemoteUserGet_result{timRemoteUserGet_result_success = timRemoteUserGet_result_success obj} then P.Nothing else P.Just $ default_TimRemoteUserGet_result{timRemoteUserGet_result_success = timRemoteUserGet_result_success obj}
    ]
from_TimRemoteUserGet_result :: TimRemoteUserGet_result -> T.ThriftVal
from_TimRemoteUserGet_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v644 -> P.Just (0, ("success",from_TimRemoteUserBean _v644))) $ timRemoteUserGet_result_success record
  ]
write_TimRemoteUserGet_result :: (T.Protocol p, T.Transport t) => p t -> TimRemoteUserGet_result -> P.IO ()
write_TimRemoteUserGet_result oprot record = T.writeVal oprot $ from_TimRemoteUserGet_result record
encode_TimRemoteUserGet_result :: (T.Protocol p, T.Transport t) => p t -> TimRemoteUserGet_result -> LBS.ByteString
encode_TimRemoteUserGet_result oprot record = T.serializeVal oprot $ from_TimRemoteUserGet_result record
to_TimRemoteUserGet_result :: T.ThriftVal -> TimRemoteUserGet_result
to_TimRemoteUserGet_result (T.TStruct fields) = TimRemoteUserGet_result{
  timRemoteUserGet_result_success = P.maybe (timRemoteUserGet_result_success default_TimRemoteUserGet_result) (\(_,_val646) -> (case _val646 of {T.TStruct _val647 -> (to_TimRemoteUserBean (T.TStruct _val647)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_TimRemoteUserGet_result _ = P.error "not a struct"
read_TimRemoteUserGet_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimRemoteUserGet_result
read_TimRemoteUserGet_result iprot = to_TimRemoteUserGet_result <$> T.readVal iprot (T.T_STRUCT typemap_TimRemoteUserGet_result)
decode_TimRemoteUserGet_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimRemoteUserGet_result
decode_TimRemoteUserGet_result iprot bs = to_TimRemoteUserGet_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimRemoteUserGet_result) bs
typemap_TimRemoteUserGet_result :: T.TypeMap
typemap_TimRemoteUserGet_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TimRemoteUserBean)))]
default_TimRemoteUserGet_result :: TimRemoteUserGet_result
default_TimRemoteUserGet_result = TimRemoteUserGet_result{
  timRemoteUserGet_result_success = default_TimRemoteUserBean}
data TimRemoteUserEdit_args = TimRemoteUserEdit_args  { timRemoteUserEdit_args_tid :: Tid
  , timRemoteUserEdit_args_ub :: TimUserBean
  , timRemoteUserEdit_args_auth :: TimAuth
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimRemoteUserEdit_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timRemoteUserEdit_args_tid record   `H.hashWithSalt` timRemoteUserEdit_args_ub record   `H.hashWithSalt` timRemoteUserEdit_args_auth record  
instance QC.Arbitrary TimRemoteUserEdit_args where 
  arbitrary = M.liftM TimRemoteUserEdit_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TimRemoteUserEdit_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimRemoteUserEdit_args{timRemoteUserEdit_args_tid = timRemoteUserEdit_args_tid obj} then P.Nothing else P.Just $ default_TimRemoteUserEdit_args{timRemoteUserEdit_args_tid = timRemoteUserEdit_args_tid obj}
    , if obj == default_TimRemoteUserEdit_args{timRemoteUserEdit_args_ub = timRemoteUserEdit_args_ub obj} then P.Nothing else P.Just $ default_TimRemoteUserEdit_args{timRemoteUserEdit_args_ub = timRemoteUserEdit_args_ub obj}
    , if obj == default_TimRemoteUserEdit_args{timRemoteUserEdit_args_auth = timRemoteUserEdit_args_auth obj} then P.Nothing else P.Just $ default_TimRemoteUserEdit_args{timRemoteUserEdit_args_auth = timRemoteUserEdit_args_auth obj}
    ]
from_TimRemoteUserEdit_args :: TimRemoteUserEdit_args -> T.ThriftVal
from_TimRemoteUserEdit_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v650 -> P.Just (1, ("tid",from_Tid _v650))) $ timRemoteUserEdit_args_tid record
  , (\_v650 -> P.Just (2, ("ub",from_TimUserBean _v650))) $ timRemoteUserEdit_args_ub record
  , (\_v650 -> P.Just (3, ("auth",from_TimAuth _v650))) $ timRemoteUserEdit_args_auth record
  ]
write_TimRemoteUserEdit_args :: (T.Protocol p, T.Transport t) => p t -> TimRemoteUserEdit_args -> P.IO ()
write_TimRemoteUserEdit_args oprot record = T.writeVal oprot $ from_TimRemoteUserEdit_args record
encode_TimRemoteUserEdit_args :: (T.Protocol p, T.Transport t) => p t -> TimRemoteUserEdit_args -> LBS.ByteString
encode_TimRemoteUserEdit_args oprot record = T.serializeVal oprot $ from_TimRemoteUserEdit_args record
to_TimRemoteUserEdit_args :: T.ThriftVal -> TimRemoteUserEdit_args
to_TimRemoteUserEdit_args (T.TStruct fields) = TimRemoteUserEdit_args{
  timRemoteUserEdit_args_tid = P.maybe (timRemoteUserEdit_args_tid default_TimRemoteUserEdit_args) (\(_,_val652) -> (case _val652 of {T.TStruct _val653 -> (to_Tid (T.TStruct _val653)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timRemoteUserEdit_args_ub = P.maybe (timRemoteUserEdit_args_ub default_TimRemoteUserEdit_args) (\(_,_val652) -> (case _val652 of {T.TStruct _val654 -> (to_TimUserBean (T.TStruct _val654)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timRemoteUserEdit_args_auth = P.maybe (timRemoteUserEdit_args_auth default_TimRemoteUserEdit_args) (\(_,_val652) -> (case _val652 of {T.TStruct _val655 -> (to_TimAuth (T.TStruct _val655)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_TimRemoteUserEdit_args _ = P.error "not a struct"
read_TimRemoteUserEdit_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimRemoteUserEdit_args
read_TimRemoteUserEdit_args iprot = to_TimRemoteUserEdit_args <$> T.readVal iprot (T.T_STRUCT typemap_TimRemoteUserEdit_args)
decode_TimRemoteUserEdit_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimRemoteUserEdit_args
decode_TimRemoteUserEdit_args iprot bs = to_TimRemoteUserEdit_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimRemoteUserEdit_args) bs
typemap_TimRemoteUserEdit_args :: T.TypeMap
typemap_TimRemoteUserEdit_args = Map.fromList [(1,("tid",(T.T_STRUCT typemap_Tid))),(2,("ub",(T.T_STRUCT typemap_TimUserBean))),(3,("auth",(T.T_STRUCT typemap_TimAuth)))]
default_TimRemoteUserEdit_args :: TimRemoteUserEdit_args
default_TimRemoteUserEdit_args = TimRemoteUserEdit_args{
  timRemoteUserEdit_args_tid = default_Tid,
  timRemoteUserEdit_args_ub = default_TimUserBean,
  timRemoteUserEdit_args_auth = default_TimAuth}
data TimRemoteUserEdit_result = TimRemoteUserEdit_result  { timRemoteUserEdit_result_success :: TimRemoteUserBean
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimRemoteUserEdit_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` timRemoteUserEdit_result_success record  
instance QC.Arbitrary TimRemoteUserEdit_result where 
  arbitrary = M.liftM TimRemoteUserEdit_result (QC.arbitrary)
  shrink obj | obj == default_TimRemoteUserEdit_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimRemoteUserEdit_result{timRemoteUserEdit_result_success = timRemoteUserEdit_result_success obj} then P.Nothing else P.Just $ default_TimRemoteUserEdit_result{timRemoteUserEdit_result_success = timRemoteUserEdit_result_success obj}
    ]
from_TimRemoteUserEdit_result :: TimRemoteUserEdit_result -> T.ThriftVal
from_TimRemoteUserEdit_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v658 -> P.Just (0, ("success",from_TimRemoteUserBean _v658))) $ timRemoteUserEdit_result_success record
  ]
write_TimRemoteUserEdit_result :: (T.Protocol p, T.Transport t) => p t -> TimRemoteUserEdit_result -> P.IO ()
write_TimRemoteUserEdit_result oprot record = T.writeVal oprot $ from_TimRemoteUserEdit_result record
encode_TimRemoteUserEdit_result :: (T.Protocol p, T.Transport t) => p t -> TimRemoteUserEdit_result -> LBS.ByteString
encode_TimRemoteUserEdit_result oprot record = T.serializeVal oprot $ from_TimRemoteUserEdit_result record
to_TimRemoteUserEdit_result :: T.ThriftVal -> TimRemoteUserEdit_result
to_TimRemoteUserEdit_result (T.TStruct fields) = TimRemoteUserEdit_result{
  timRemoteUserEdit_result_success = P.maybe (timRemoteUserEdit_result_success default_TimRemoteUserEdit_result) (\(_,_val660) -> (case _val660 of {T.TStruct _val661 -> (to_TimRemoteUserBean (T.TStruct _val661)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_TimRemoteUserEdit_result _ = P.error "not a struct"
read_TimRemoteUserEdit_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimRemoteUserEdit_result
read_TimRemoteUserEdit_result iprot = to_TimRemoteUserEdit_result <$> T.readVal iprot (T.T_STRUCT typemap_TimRemoteUserEdit_result)
decode_TimRemoteUserEdit_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimRemoteUserEdit_result
decode_TimRemoteUserEdit_result iprot bs = to_TimRemoteUserEdit_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimRemoteUserEdit_result) bs
typemap_TimRemoteUserEdit_result :: T.TypeMap
typemap_TimRemoteUserEdit_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TimRemoteUserBean)))]
default_TimRemoteUserEdit_result :: TimRemoteUserEdit_result
default_TimRemoteUserEdit_result = TimRemoteUserEdit_result{
  timRemoteUserEdit_result_success = default_TimRemoteUserBean}
data TimResponsePresence_args = TimResponsePresence_args  { timResponsePresence_args_pbean :: TimPBean
  , timResponsePresence_args_auth :: TimAuth
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimResponsePresence_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timResponsePresence_args_pbean record   `H.hashWithSalt` timResponsePresence_args_auth record  
instance QC.Arbitrary TimResponsePresence_args where 
  arbitrary = M.liftM TimResponsePresence_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TimResponsePresence_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimResponsePresence_args{timResponsePresence_args_pbean = timResponsePresence_args_pbean obj} then P.Nothing else P.Just $ default_TimResponsePresence_args{timResponsePresence_args_pbean = timResponsePresence_args_pbean obj}
    , if obj == default_TimResponsePresence_args{timResponsePresence_args_auth = timResponsePresence_args_auth obj} then P.Nothing else P.Just $ default_TimResponsePresence_args{timResponsePresence_args_auth = timResponsePresence_args_auth obj}
    ]
from_TimResponsePresence_args :: TimResponsePresence_args -> T.ThriftVal
from_TimResponsePresence_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v664 -> P.Just (1, ("pbean",from_TimPBean _v664))) $ timResponsePresence_args_pbean record
  , (\_v664 -> P.Just (2, ("auth",from_TimAuth _v664))) $ timResponsePresence_args_auth record
  ]
write_TimResponsePresence_args :: (T.Protocol p, T.Transport t) => p t -> TimResponsePresence_args -> P.IO ()
write_TimResponsePresence_args oprot record = T.writeVal oprot $ from_TimResponsePresence_args record
encode_TimResponsePresence_args :: (T.Protocol p, T.Transport t) => p t -> TimResponsePresence_args -> LBS.ByteString
encode_TimResponsePresence_args oprot record = T.serializeVal oprot $ from_TimResponsePresence_args record
to_TimResponsePresence_args :: T.ThriftVal -> TimResponsePresence_args
to_TimResponsePresence_args (T.TStruct fields) = TimResponsePresence_args{
  timResponsePresence_args_pbean = P.maybe (timResponsePresence_args_pbean default_TimResponsePresence_args) (\(_,_val666) -> (case _val666 of {T.TStruct _val667 -> (to_TimPBean (T.TStruct _val667)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timResponsePresence_args_auth = P.maybe (timResponsePresence_args_auth default_TimResponsePresence_args) (\(_,_val666) -> (case _val666 of {T.TStruct _val668 -> (to_TimAuth (T.TStruct _val668)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TimResponsePresence_args _ = P.error "not a struct"
read_TimResponsePresence_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimResponsePresence_args
read_TimResponsePresence_args iprot = to_TimResponsePresence_args <$> T.readVal iprot (T.T_STRUCT typemap_TimResponsePresence_args)
decode_TimResponsePresence_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimResponsePresence_args
decode_TimResponsePresence_args iprot bs = to_TimResponsePresence_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimResponsePresence_args) bs
typemap_TimResponsePresence_args :: T.TypeMap
typemap_TimResponsePresence_args = Map.fromList [(1,("pbean",(T.T_STRUCT typemap_TimPBean))),(2,("auth",(T.T_STRUCT typemap_TimAuth)))]
default_TimResponsePresence_args :: TimResponsePresence_args
default_TimResponsePresence_args = TimResponsePresence_args{
  timResponsePresence_args_pbean = default_TimPBean,
  timResponsePresence_args_auth = default_TimAuth}
data TimResponsePresence_result = TimResponsePresence_result  { timResponsePresence_result_success :: TimResponseBean
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimResponsePresence_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` timResponsePresence_result_success record  
instance QC.Arbitrary TimResponsePresence_result where 
  arbitrary = M.liftM TimResponsePresence_result (QC.arbitrary)
  shrink obj | obj == default_TimResponsePresence_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimResponsePresence_result{timResponsePresence_result_success = timResponsePresence_result_success obj} then P.Nothing else P.Just $ default_TimResponsePresence_result{timResponsePresence_result_success = timResponsePresence_result_success obj}
    ]
from_TimResponsePresence_result :: TimResponsePresence_result -> T.ThriftVal
from_TimResponsePresence_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v671 -> P.Just (0, ("success",from_TimResponseBean _v671))) $ timResponsePresence_result_success record
  ]
write_TimResponsePresence_result :: (T.Protocol p, T.Transport t) => p t -> TimResponsePresence_result -> P.IO ()
write_TimResponsePresence_result oprot record = T.writeVal oprot $ from_TimResponsePresence_result record
encode_TimResponsePresence_result :: (T.Protocol p, T.Transport t) => p t -> TimResponsePresence_result -> LBS.ByteString
encode_TimResponsePresence_result oprot record = T.serializeVal oprot $ from_TimResponsePresence_result record
to_TimResponsePresence_result :: T.ThriftVal -> TimResponsePresence_result
to_TimResponsePresence_result (T.TStruct fields) = TimResponsePresence_result{
  timResponsePresence_result_success = P.maybe (timResponsePresence_result_success default_TimResponsePresence_result) (\(_,_val673) -> (case _val673 of {T.TStruct _val674 -> (to_TimResponseBean (T.TStruct _val674)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_TimResponsePresence_result _ = P.error "not a struct"
read_TimResponsePresence_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimResponsePresence_result
read_TimResponsePresence_result iprot = to_TimResponsePresence_result <$> T.readVal iprot (T.T_STRUCT typemap_TimResponsePresence_result)
decode_TimResponsePresence_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimResponsePresence_result
decode_TimResponsePresence_result iprot bs = to_TimResponsePresence_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimResponsePresence_result) bs
typemap_TimResponsePresence_result :: T.TypeMap
typemap_TimResponsePresence_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TimResponseBean)))]
default_TimResponsePresence_result :: TimResponsePresence_result
default_TimResponsePresence_result = TimResponsePresence_result{
  timResponsePresence_result_success = default_TimResponseBean}
data TimResponseMessage_args = TimResponseMessage_args  { timResponseMessage_args_mbean :: TimMBean
  , timResponseMessage_args_auth :: TimAuth
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimResponseMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timResponseMessage_args_mbean record   `H.hashWithSalt` timResponseMessage_args_auth record  
instance QC.Arbitrary TimResponseMessage_args where 
  arbitrary = M.liftM TimResponseMessage_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TimResponseMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimResponseMessage_args{timResponseMessage_args_mbean = timResponseMessage_args_mbean obj} then P.Nothing else P.Just $ default_TimResponseMessage_args{timResponseMessage_args_mbean = timResponseMessage_args_mbean obj}
    , if obj == default_TimResponseMessage_args{timResponseMessage_args_auth = timResponseMessage_args_auth obj} then P.Nothing else P.Just $ default_TimResponseMessage_args{timResponseMessage_args_auth = timResponseMessage_args_auth obj}
    ]
from_TimResponseMessage_args :: TimResponseMessage_args -> T.ThriftVal
from_TimResponseMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v677 -> P.Just (1, ("mbean",from_TimMBean _v677))) $ timResponseMessage_args_mbean record
  , (\_v677 -> P.Just (2, ("auth",from_TimAuth _v677))) $ timResponseMessage_args_auth record
  ]
write_TimResponseMessage_args :: (T.Protocol p, T.Transport t) => p t -> TimResponseMessage_args -> P.IO ()
write_TimResponseMessage_args oprot record = T.writeVal oprot $ from_TimResponseMessage_args record
encode_TimResponseMessage_args :: (T.Protocol p, T.Transport t) => p t -> TimResponseMessage_args -> LBS.ByteString
encode_TimResponseMessage_args oprot record = T.serializeVal oprot $ from_TimResponseMessage_args record
to_TimResponseMessage_args :: T.ThriftVal -> TimResponseMessage_args
to_TimResponseMessage_args (T.TStruct fields) = TimResponseMessage_args{
  timResponseMessage_args_mbean = P.maybe (timResponseMessage_args_mbean default_TimResponseMessage_args) (\(_,_val679) -> (case _val679 of {T.TStruct _val680 -> (to_TimMBean (T.TStruct _val680)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timResponseMessage_args_auth = P.maybe (timResponseMessage_args_auth default_TimResponseMessage_args) (\(_,_val679) -> (case _val679 of {T.TStruct _val681 -> (to_TimAuth (T.TStruct _val681)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TimResponseMessage_args _ = P.error "not a struct"
read_TimResponseMessage_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimResponseMessage_args
read_TimResponseMessage_args iprot = to_TimResponseMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_TimResponseMessage_args)
decode_TimResponseMessage_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimResponseMessage_args
decode_TimResponseMessage_args iprot bs = to_TimResponseMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimResponseMessage_args) bs
typemap_TimResponseMessage_args :: T.TypeMap
typemap_TimResponseMessage_args = Map.fromList [(1,("mbean",(T.T_STRUCT typemap_TimMBean))),(2,("auth",(T.T_STRUCT typemap_TimAuth)))]
default_TimResponseMessage_args :: TimResponseMessage_args
default_TimResponseMessage_args = TimResponseMessage_args{
  timResponseMessage_args_mbean = default_TimMBean,
  timResponseMessage_args_auth = default_TimAuth}
data TimResponseMessage_result = TimResponseMessage_result  { timResponseMessage_result_success :: TimResponseBean
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimResponseMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` timResponseMessage_result_success record  
instance QC.Arbitrary TimResponseMessage_result where 
  arbitrary = M.liftM TimResponseMessage_result (QC.arbitrary)
  shrink obj | obj == default_TimResponseMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimResponseMessage_result{timResponseMessage_result_success = timResponseMessage_result_success obj} then P.Nothing else P.Just $ default_TimResponseMessage_result{timResponseMessage_result_success = timResponseMessage_result_success obj}
    ]
from_TimResponseMessage_result :: TimResponseMessage_result -> T.ThriftVal
from_TimResponseMessage_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v684 -> P.Just (0, ("success",from_TimResponseBean _v684))) $ timResponseMessage_result_success record
  ]
write_TimResponseMessage_result :: (T.Protocol p, T.Transport t) => p t -> TimResponseMessage_result -> P.IO ()
write_TimResponseMessage_result oprot record = T.writeVal oprot $ from_TimResponseMessage_result record
encode_TimResponseMessage_result :: (T.Protocol p, T.Transport t) => p t -> TimResponseMessage_result -> LBS.ByteString
encode_TimResponseMessage_result oprot record = T.serializeVal oprot $ from_TimResponseMessage_result record
to_TimResponseMessage_result :: T.ThriftVal -> TimResponseMessage_result
to_TimResponseMessage_result (T.TStruct fields) = TimResponseMessage_result{
  timResponseMessage_result_success = P.maybe (timResponseMessage_result_success default_TimResponseMessage_result) (\(_,_val686) -> (case _val686 of {T.TStruct _val687 -> (to_TimResponseBean (T.TStruct _val687)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_TimResponseMessage_result _ = P.error "not a struct"
read_TimResponseMessage_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimResponseMessage_result
read_TimResponseMessage_result iprot = to_TimResponseMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_TimResponseMessage_result)
decode_TimResponseMessage_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimResponseMessage_result
decode_TimResponseMessage_result iprot bs = to_TimResponseMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimResponseMessage_result) bs
typemap_TimResponseMessage_result :: T.TypeMap
typemap_TimResponseMessage_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TimResponseBean)))]
default_TimResponseMessage_result :: TimResponseMessage_result
default_TimResponseMessage_result = TimResponseMessage_result{
  timResponseMessage_result_success = default_TimResponseBean}
data TimResponseMessageIq_args = TimResponseMessageIq_args  { timResponseMessageIq_args_timMsgIq :: TimMessageIq
  , timResponseMessageIq_args_iqType :: LT.Text
  , timResponseMessageIq_args_auth :: TimAuth
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimResponseMessageIq_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timResponseMessageIq_args_timMsgIq record   `H.hashWithSalt` timResponseMessageIq_args_iqType record   `H.hashWithSalt` timResponseMessageIq_args_auth record  
instance QC.Arbitrary TimResponseMessageIq_args where 
  arbitrary = M.liftM TimResponseMessageIq_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TimResponseMessageIq_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimResponseMessageIq_args{timResponseMessageIq_args_timMsgIq = timResponseMessageIq_args_timMsgIq obj} then P.Nothing else P.Just $ default_TimResponseMessageIq_args{timResponseMessageIq_args_timMsgIq = timResponseMessageIq_args_timMsgIq obj}
    , if obj == default_TimResponseMessageIq_args{timResponseMessageIq_args_iqType = timResponseMessageIq_args_iqType obj} then P.Nothing else P.Just $ default_TimResponseMessageIq_args{timResponseMessageIq_args_iqType = timResponseMessageIq_args_iqType obj}
    , if obj == default_TimResponseMessageIq_args{timResponseMessageIq_args_auth = timResponseMessageIq_args_auth obj} then P.Nothing else P.Just $ default_TimResponseMessageIq_args{timResponseMessageIq_args_auth = timResponseMessageIq_args_auth obj}
    ]
from_TimResponseMessageIq_args :: TimResponseMessageIq_args -> T.ThriftVal
from_TimResponseMessageIq_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v690 -> P.Just (1, ("timMsgIq",from_TimMessageIq _v690))) $ timResponseMessageIq_args_timMsgIq record
  , (\_v690 -> P.Just (2, ("iqType",T.TString $ E.encodeUtf8 _v690))) $ timResponseMessageIq_args_iqType record
  , (\_v690 -> P.Just (3, ("auth",from_TimAuth _v690))) $ timResponseMessageIq_args_auth record
  ]
write_TimResponseMessageIq_args :: (T.Protocol p, T.Transport t) => p t -> TimResponseMessageIq_args -> P.IO ()
write_TimResponseMessageIq_args oprot record = T.writeVal oprot $ from_TimResponseMessageIq_args record
encode_TimResponseMessageIq_args :: (T.Protocol p, T.Transport t) => p t -> TimResponseMessageIq_args -> LBS.ByteString
encode_TimResponseMessageIq_args oprot record = T.serializeVal oprot $ from_TimResponseMessageIq_args record
to_TimResponseMessageIq_args :: T.ThriftVal -> TimResponseMessageIq_args
to_TimResponseMessageIq_args (T.TStruct fields) = TimResponseMessageIq_args{
  timResponseMessageIq_args_timMsgIq = P.maybe (timResponseMessageIq_args_timMsgIq default_TimResponseMessageIq_args) (\(_,_val692) -> (case _val692 of {T.TStruct _val693 -> (to_TimMessageIq (T.TStruct _val693)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timResponseMessageIq_args_iqType = P.maybe (timResponseMessageIq_args_iqType default_TimResponseMessageIq_args) (\(_,_val692) -> (case _val692 of {T.TString _val694 -> E.decodeUtf8 _val694; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timResponseMessageIq_args_auth = P.maybe (timResponseMessageIq_args_auth default_TimResponseMessageIq_args) (\(_,_val692) -> (case _val692 of {T.TStruct _val695 -> (to_TimAuth (T.TStruct _val695)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_TimResponseMessageIq_args _ = P.error "not a struct"
read_TimResponseMessageIq_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimResponseMessageIq_args
read_TimResponseMessageIq_args iprot = to_TimResponseMessageIq_args <$> T.readVal iprot (T.T_STRUCT typemap_TimResponseMessageIq_args)
decode_TimResponseMessageIq_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimResponseMessageIq_args
decode_TimResponseMessageIq_args iprot bs = to_TimResponseMessageIq_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimResponseMessageIq_args) bs
typemap_TimResponseMessageIq_args :: T.TypeMap
typemap_TimResponseMessageIq_args = Map.fromList [(1,("timMsgIq",(T.T_STRUCT typemap_TimMessageIq))),(2,("iqType",T.T_STRING)),(3,("auth",(T.T_STRUCT typemap_TimAuth)))]
default_TimResponseMessageIq_args :: TimResponseMessageIq_args
default_TimResponseMessageIq_args = TimResponseMessageIq_args{
  timResponseMessageIq_args_timMsgIq = default_TimMessageIq,
  timResponseMessageIq_args_iqType = "",
  timResponseMessageIq_args_auth = default_TimAuth}
data TimResponseMessageIq_result = TimResponseMessageIq_result  { timResponseMessageIq_result_success :: TimMBeanList
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimResponseMessageIq_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` timResponseMessageIq_result_success record  
instance QC.Arbitrary TimResponseMessageIq_result where 
  arbitrary = M.liftM TimResponseMessageIq_result (QC.arbitrary)
  shrink obj | obj == default_TimResponseMessageIq_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimResponseMessageIq_result{timResponseMessageIq_result_success = timResponseMessageIq_result_success obj} then P.Nothing else P.Just $ default_TimResponseMessageIq_result{timResponseMessageIq_result_success = timResponseMessageIq_result_success obj}
    ]
from_TimResponseMessageIq_result :: TimResponseMessageIq_result -> T.ThriftVal
from_TimResponseMessageIq_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v698 -> P.Just (0, ("success",from_TimMBeanList _v698))) $ timResponseMessageIq_result_success record
  ]
write_TimResponseMessageIq_result :: (T.Protocol p, T.Transport t) => p t -> TimResponseMessageIq_result -> P.IO ()
write_TimResponseMessageIq_result oprot record = T.writeVal oprot $ from_TimResponseMessageIq_result record
encode_TimResponseMessageIq_result :: (T.Protocol p, T.Transport t) => p t -> TimResponseMessageIq_result -> LBS.ByteString
encode_TimResponseMessageIq_result oprot record = T.serializeVal oprot $ from_TimResponseMessageIq_result record
to_TimResponseMessageIq_result :: T.ThriftVal -> TimResponseMessageIq_result
to_TimResponseMessageIq_result (T.TStruct fields) = TimResponseMessageIq_result{
  timResponseMessageIq_result_success = P.maybe (timResponseMessageIq_result_success default_TimResponseMessageIq_result) (\(_,_val700) -> (case _val700 of {T.TStruct _val701 -> (to_TimMBeanList (T.TStruct _val701)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_TimResponseMessageIq_result _ = P.error "not a struct"
read_TimResponseMessageIq_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimResponseMessageIq_result
read_TimResponseMessageIq_result iprot = to_TimResponseMessageIq_result <$> T.readVal iprot (T.T_STRUCT typemap_TimResponseMessageIq_result)
decode_TimResponseMessageIq_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimResponseMessageIq_result
decode_TimResponseMessageIq_result iprot bs = to_TimResponseMessageIq_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimResponseMessageIq_result) bs
typemap_TimResponseMessageIq_result :: T.TypeMap
typemap_TimResponseMessageIq_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TimMBeanList)))]
default_TimResponseMessageIq_result :: TimResponseMessageIq_result
default_TimResponseMessageIq_result = TimResponseMessageIq_result{
  timResponseMessageIq_result_success = default_TimMBeanList}
data TimResponsePresenceList_args = TimResponsePresenceList_args  { timResponsePresenceList_args_pbeanList :: TimPBeanList
  , timResponsePresenceList_args_auth :: TimAuth
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimResponsePresenceList_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timResponsePresenceList_args_pbeanList record   `H.hashWithSalt` timResponsePresenceList_args_auth record  
instance QC.Arbitrary TimResponsePresenceList_args where 
  arbitrary = M.liftM TimResponsePresenceList_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TimResponsePresenceList_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimResponsePresenceList_args{timResponsePresenceList_args_pbeanList = timResponsePresenceList_args_pbeanList obj} then P.Nothing else P.Just $ default_TimResponsePresenceList_args{timResponsePresenceList_args_pbeanList = timResponsePresenceList_args_pbeanList obj}
    , if obj == default_TimResponsePresenceList_args{timResponsePresenceList_args_auth = timResponsePresenceList_args_auth obj} then P.Nothing else P.Just $ default_TimResponsePresenceList_args{timResponsePresenceList_args_auth = timResponsePresenceList_args_auth obj}
    ]
from_TimResponsePresenceList_args :: TimResponsePresenceList_args -> T.ThriftVal
from_TimResponsePresenceList_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v704 -> P.Just (1, ("pbeanList",from_TimPBeanList _v704))) $ timResponsePresenceList_args_pbeanList record
  , (\_v704 -> P.Just (2, ("auth",from_TimAuth _v704))) $ timResponsePresenceList_args_auth record
  ]
write_TimResponsePresenceList_args :: (T.Protocol p, T.Transport t) => p t -> TimResponsePresenceList_args -> P.IO ()
write_TimResponsePresenceList_args oprot record = T.writeVal oprot $ from_TimResponsePresenceList_args record
encode_TimResponsePresenceList_args :: (T.Protocol p, T.Transport t) => p t -> TimResponsePresenceList_args -> LBS.ByteString
encode_TimResponsePresenceList_args oprot record = T.serializeVal oprot $ from_TimResponsePresenceList_args record
to_TimResponsePresenceList_args :: T.ThriftVal -> TimResponsePresenceList_args
to_TimResponsePresenceList_args (T.TStruct fields) = TimResponsePresenceList_args{
  timResponsePresenceList_args_pbeanList = P.maybe (timResponsePresenceList_args_pbeanList default_TimResponsePresenceList_args) (\(_,_val706) -> (case _val706 of {T.TStruct _val707 -> (to_TimPBeanList (T.TStruct _val707)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timResponsePresenceList_args_auth = P.maybe (timResponsePresenceList_args_auth default_TimResponsePresenceList_args) (\(_,_val706) -> (case _val706 of {T.TStruct _val708 -> (to_TimAuth (T.TStruct _val708)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TimResponsePresenceList_args _ = P.error "not a struct"
read_TimResponsePresenceList_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimResponsePresenceList_args
read_TimResponsePresenceList_args iprot = to_TimResponsePresenceList_args <$> T.readVal iprot (T.T_STRUCT typemap_TimResponsePresenceList_args)
decode_TimResponsePresenceList_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimResponsePresenceList_args
decode_TimResponsePresenceList_args iprot bs = to_TimResponsePresenceList_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimResponsePresenceList_args) bs
typemap_TimResponsePresenceList_args :: T.TypeMap
typemap_TimResponsePresenceList_args = Map.fromList [(1,("pbeanList",(T.T_STRUCT typemap_TimPBeanList))),(2,("auth",(T.T_STRUCT typemap_TimAuth)))]
default_TimResponsePresenceList_args :: TimResponsePresenceList_args
default_TimResponsePresenceList_args = TimResponsePresenceList_args{
  timResponsePresenceList_args_pbeanList = default_TimPBeanList,
  timResponsePresenceList_args_auth = default_TimAuth}
data TimResponsePresenceList_result = TimResponsePresenceList_result  { timResponsePresenceList_result_success :: TimResponseBean
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimResponsePresenceList_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` timResponsePresenceList_result_success record  
instance QC.Arbitrary TimResponsePresenceList_result where 
  arbitrary = M.liftM TimResponsePresenceList_result (QC.arbitrary)
  shrink obj | obj == default_TimResponsePresenceList_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimResponsePresenceList_result{timResponsePresenceList_result_success = timResponsePresenceList_result_success obj} then P.Nothing else P.Just $ default_TimResponsePresenceList_result{timResponsePresenceList_result_success = timResponsePresenceList_result_success obj}
    ]
from_TimResponsePresenceList_result :: TimResponsePresenceList_result -> T.ThriftVal
from_TimResponsePresenceList_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v711 -> P.Just (0, ("success",from_TimResponseBean _v711))) $ timResponsePresenceList_result_success record
  ]
write_TimResponsePresenceList_result :: (T.Protocol p, T.Transport t) => p t -> TimResponsePresenceList_result -> P.IO ()
write_TimResponsePresenceList_result oprot record = T.writeVal oprot $ from_TimResponsePresenceList_result record
encode_TimResponsePresenceList_result :: (T.Protocol p, T.Transport t) => p t -> TimResponsePresenceList_result -> LBS.ByteString
encode_TimResponsePresenceList_result oprot record = T.serializeVal oprot $ from_TimResponsePresenceList_result record
to_TimResponsePresenceList_result :: T.ThriftVal -> TimResponsePresenceList_result
to_TimResponsePresenceList_result (T.TStruct fields) = TimResponsePresenceList_result{
  timResponsePresenceList_result_success = P.maybe (timResponsePresenceList_result_success default_TimResponsePresenceList_result) (\(_,_val713) -> (case _val713 of {T.TStruct _val714 -> (to_TimResponseBean (T.TStruct _val714)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_TimResponsePresenceList_result _ = P.error "not a struct"
read_TimResponsePresenceList_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimResponsePresenceList_result
read_TimResponsePresenceList_result iprot = to_TimResponsePresenceList_result <$> T.readVal iprot (T.T_STRUCT typemap_TimResponsePresenceList_result)
decode_TimResponsePresenceList_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimResponsePresenceList_result
decode_TimResponsePresenceList_result iprot bs = to_TimResponsePresenceList_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimResponsePresenceList_result) bs
typemap_TimResponsePresenceList_result :: T.TypeMap
typemap_TimResponsePresenceList_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TimResponseBean)))]
default_TimResponsePresenceList_result :: TimResponsePresenceList_result
default_TimResponsePresenceList_result = TimResponsePresenceList_result{
  timResponsePresenceList_result_success = default_TimResponseBean}
data TimResponseMessageList_args = TimResponseMessageList_args  { timResponseMessageList_args_mbeanList :: TimMBeanList
  , timResponseMessageList_args_auth :: TimAuth
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimResponseMessageList_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` timResponseMessageList_args_mbeanList record   `H.hashWithSalt` timResponseMessageList_args_auth record  
instance QC.Arbitrary TimResponseMessageList_args where 
  arbitrary = M.liftM TimResponseMessageList_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TimResponseMessageList_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimResponseMessageList_args{timResponseMessageList_args_mbeanList = timResponseMessageList_args_mbeanList obj} then P.Nothing else P.Just $ default_TimResponseMessageList_args{timResponseMessageList_args_mbeanList = timResponseMessageList_args_mbeanList obj}
    , if obj == default_TimResponseMessageList_args{timResponseMessageList_args_auth = timResponseMessageList_args_auth obj} then P.Nothing else P.Just $ default_TimResponseMessageList_args{timResponseMessageList_args_auth = timResponseMessageList_args_auth obj}
    ]
from_TimResponseMessageList_args :: TimResponseMessageList_args -> T.ThriftVal
from_TimResponseMessageList_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v717 -> P.Just (1, ("mbeanList",from_TimMBeanList _v717))) $ timResponseMessageList_args_mbeanList record
  , (\_v717 -> P.Just (2, ("auth",from_TimAuth _v717))) $ timResponseMessageList_args_auth record
  ]
write_TimResponseMessageList_args :: (T.Protocol p, T.Transport t) => p t -> TimResponseMessageList_args -> P.IO ()
write_TimResponseMessageList_args oprot record = T.writeVal oprot $ from_TimResponseMessageList_args record
encode_TimResponseMessageList_args :: (T.Protocol p, T.Transport t) => p t -> TimResponseMessageList_args -> LBS.ByteString
encode_TimResponseMessageList_args oprot record = T.serializeVal oprot $ from_TimResponseMessageList_args record
to_TimResponseMessageList_args :: T.ThriftVal -> TimResponseMessageList_args
to_TimResponseMessageList_args (T.TStruct fields) = TimResponseMessageList_args{
  timResponseMessageList_args_mbeanList = P.maybe (timResponseMessageList_args_mbeanList default_TimResponseMessageList_args) (\(_,_val719) -> (case _val719 of {T.TStruct _val720 -> (to_TimMBeanList (T.TStruct _val720)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timResponseMessageList_args_auth = P.maybe (timResponseMessageList_args_auth default_TimResponseMessageList_args) (\(_,_val719) -> (case _val719 of {T.TStruct _val721 -> (to_TimAuth (T.TStruct _val721)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TimResponseMessageList_args _ = P.error "not a struct"
read_TimResponseMessageList_args :: (T.Transport t, T.Protocol p) => p t -> P.IO TimResponseMessageList_args
read_TimResponseMessageList_args iprot = to_TimResponseMessageList_args <$> T.readVal iprot (T.T_STRUCT typemap_TimResponseMessageList_args)
decode_TimResponseMessageList_args :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimResponseMessageList_args
decode_TimResponseMessageList_args iprot bs = to_TimResponseMessageList_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TimResponseMessageList_args) bs
typemap_TimResponseMessageList_args :: T.TypeMap
typemap_TimResponseMessageList_args = Map.fromList [(1,("mbeanList",(T.T_STRUCT typemap_TimMBeanList))),(2,("auth",(T.T_STRUCT typemap_TimAuth)))]
default_TimResponseMessageList_args :: TimResponseMessageList_args
default_TimResponseMessageList_args = TimResponseMessageList_args{
  timResponseMessageList_args_mbeanList = default_TimMBeanList,
  timResponseMessageList_args_auth = default_TimAuth}
data TimResponseMessageList_result = TimResponseMessageList_result  { timResponseMessageList_result_success :: TimResponseBean
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimResponseMessageList_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` timResponseMessageList_result_success record  
instance QC.Arbitrary TimResponseMessageList_result where 
  arbitrary = M.liftM TimResponseMessageList_result (QC.arbitrary)
  shrink obj | obj == default_TimResponseMessageList_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimResponseMessageList_result{timResponseMessageList_result_success = timResponseMessageList_result_success obj} then P.Nothing else P.Just $ default_TimResponseMessageList_result{timResponseMessageList_result_success = timResponseMessageList_result_success obj}
    ]
from_TimResponseMessageList_result :: TimResponseMessageList_result -> T.ThriftVal
from_TimResponseMessageList_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v724 -> P.Just (0, ("success",from_TimResponseBean _v724))) $ timResponseMessageList_result_success record
  ]
write_TimResponseMessageList_result :: (T.Protocol p, T.Transport t) => p t -> TimResponseMessageList_result -> P.IO ()
write_TimResponseMessageList_result oprot record = T.writeVal oprot $ from_TimResponseMessageList_result record
encode_TimResponseMessageList_result :: (T.Protocol p, T.Transport t) => p t -> TimResponseMessageList_result -> LBS.ByteString
encode_TimResponseMessageList_result oprot record = T.serializeVal oprot $ from_TimResponseMessageList_result record
to_TimResponseMessageList_result :: T.ThriftVal -> TimResponseMessageList_result
to_TimResponseMessageList_result (T.TStruct fields) = TimResponseMessageList_result{
  timResponseMessageList_result_success = P.maybe (timResponseMessageList_result_success default_TimResponseMessageList_result) (\(_,_val726) -> (case _val726 of {T.TStruct _val727 -> (to_TimResponseBean (T.TStruct _val727)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_TimResponseMessageList_result _ = P.error "not a struct"
read_TimResponseMessageList_result :: (T.Transport t, T.Protocol p) => p t -> P.IO TimResponseMessageList_result
read_TimResponseMessageList_result iprot = to_TimResponseMessageList_result <$> T.readVal iprot (T.T_STRUCT typemap_TimResponseMessageList_result)
decode_TimResponseMessageList_result :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimResponseMessageList_result
decode_TimResponseMessageList_result iprot bs = to_TimResponseMessageList_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TimResponseMessageList_result) bs
typemap_TimResponseMessageList_result :: T.TypeMap
typemap_TimResponseMessageList_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TimResponseBean)))]
default_TimResponseMessageList_result :: TimResponseMessageList_result
default_TimResponseMessageList_result = TimResponseMessageList_result{
  timResponseMessageList_result_success = default_TimResponseBean}
process_timStream (seqid, iprot, oprot, handler) = do
  args <- read_TimStream_args iprot
  (X.catch
    (do
      Iface.timStream handler (timStream_args_param args)
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
process_timStarttls (seqid, iprot, oprot, handler) = do
  args <- read_TimStarttls_args iprot
  (X.catch
    (do
      Iface.timStarttls handler
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
process_timLogin (seqid, iprot, oprot, handler) = do
  args <- read_TimLogin_args iprot
  (X.catch
    (do
      Iface.timLogin handler (timLogin_args_tid args) (timLogin_args_pwd args)
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
process_timAck (seqid, iprot, oprot, handler) = do
  args <- read_TimAck_args iprot
  (X.catch
    (do
      Iface.timAck handler (timAck_args_ab args)
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
process_timPresence (seqid, iprot, oprot, handler) = do
  args <- read_TimPresence_args iprot
  (X.catch
    (do
      Iface.timPresence handler (timPresence_args_pbean args)
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
process_timMessage (seqid, iprot, oprot, handler) = do
  args <- read_TimMessage_args iprot
  (X.catch
    (do
      Iface.timMessage handler (timMessage_args_mbean args)
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
process_timPing (seqid, iprot, oprot, handler) = do
  args <- read_TimPing_args iprot
  (X.catch
    (do
      Iface.timPing handler (timPing_args_threadId args)
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
process_timError (seqid, iprot, oprot, handler) = do
  args <- read_TimError_args iprot
  (X.catch
    (do
      Iface.timError handler (timError_args_e args)
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
process_timLogout (seqid, iprot, oprot, handler) = do
  args <- read_TimLogout_args iprot
  (X.catch
    (do
      Iface.timLogout handler
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
process_timRegist (seqid, iprot, oprot, handler) = do
  args <- read_TimRegist_args iprot
  (X.catch
    (do
      Iface.timRegist handler (timRegist_args_tid args) (timRegist_args_auth args)
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
process_timRoser (seqid, iprot, oprot, handler) = do
  args <- read_TimRoser_args iprot
  (X.catch
    (do
      Iface.timRoser handler (timRoser_args_roster args)
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
process_timMessageList (seqid, iprot, oprot, handler) = do
  args <- read_TimMessageList_args iprot
  (X.catch
    (do
      Iface.timMessageList handler (timMessageList_args_mbeanList args)
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
process_timPresenceList (seqid, iprot, oprot, handler) = do
  args <- read_TimPresenceList_args iprot
  (X.catch
    (do
      Iface.timPresenceList handler (timPresenceList_args_pbeanList args)
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
process_timMessageIq (seqid, iprot, oprot, handler) = do
  args <- read_TimMessageIq_args iprot
  (X.catch
    (do
      Iface.timMessageIq handler (timMessageIq_args_timMsgIq args) (timMessageIq_args_iqType args)
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
process_timMessageResult (seqid, iprot, oprot, handler) = do
  args <- read_TimMessageResult_args iprot
  (X.catch
    (do
      Iface.timMessageResult handler (timMessageResult_args_mbean args)
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
process_timProperty (seqid, iprot, oprot, handler) = do
  args <- read_TimProperty_args iprot
  (X.catch
    (do
      Iface.timProperty handler (timProperty_args_tpb args)
      P.return ())
    ((\_ -> do
      P.return ()) :: X.SomeException -> P.IO ()))
process_timRemoteUserAuth (seqid, iprot, oprot, handler) = do
  args <- read_TimRemoteUserAuth_args iprot
  (X.catch
    (do
      val <- Iface.timRemoteUserAuth handler (timRemoteUserAuth_args_tid args) (timRemoteUserAuth_args_pwd args) (timRemoteUserAuth_args_auth args)
      let res = default_TimRemoteUserAuth_result{timRemoteUserAuth_result_success = val}
      T.writeMessageBegin oprot ("timRemoteUserAuth", T.M_REPLY, seqid)
      write_TimRemoteUserAuth_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("timRemoteUserAuth", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_timRemoteUserGet (seqid, iprot, oprot, handler) = do
  args <- read_TimRemoteUserGet_args iprot
  (X.catch
    (do
      val <- Iface.timRemoteUserGet handler (timRemoteUserGet_args_tid args) (timRemoteUserGet_args_auth args)
      let res = default_TimRemoteUserGet_result{timRemoteUserGet_result_success = val}
      T.writeMessageBegin oprot ("timRemoteUserGet", T.M_REPLY, seqid)
      write_TimRemoteUserGet_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("timRemoteUserGet", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_timRemoteUserEdit (seqid, iprot, oprot, handler) = do
  args <- read_TimRemoteUserEdit_args iprot
  (X.catch
    (do
      val <- Iface.timRemoteUserEdit handler (timRemoteUserEdit_args_tid args) (timRemoteUserEdit_args_ub args) (timRemoteUserEdit_args_auth args)
      let res = default_TimRemoteUserEdit_result{timRemoteUserEdit_result_success = val}
      T.writeMessageBegin oprot ("timRemoteUserEdit", T.M_REPLY, seqid)
      write_TimRemoteUserEdit_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("timRemoteUserEdit", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_timResponsePresence (seqid, iprot, oprot, handler) = do
  args <- read_TimResponsePresence_args iprot
  (X.catch
    (do
      val <- Iface.timResponsePresence handler (timResponsePresence_args_pbean args) (timResponsePresence_args_auth args)
      let res = default_TimResponsePresence_result{timResponsePresence_result_success = val}
      T.writeMessageBegin oprot ("timResponsePresence", T.M_REPLY, seqid)
      write_TimResponsePresence_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("timResponsePresence", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_timResponseMessage (seqid, iprot, oprot, handler) = do
  args <- read_TimResponseMessage_args iprot
  (X.catch
    (do
      val <- Iface.timResponseMessage handler (timResponseMessage_args_mbean args) (timResponseMessage_args_auth args)
      let res = default_TimResponseMessage_result{timResponseMessage_result_success = val}
      T.writeMessageBegin oprot ("timResponseMessage", T.M_REPLY, seqid)
      write_TimResponseMessage_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("timResponseMessage", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_timResponseMessageIq (seqid, iprot, oprot, handler) = do
  args <- read_TimResponseMessageIq_args iprot
  (X.catch
    (do
      val <- Iface.timResponseMessageIq handler (timResponseMessageIq_args_timMsgIq args) (timResponseMessageIq_args_iqType args) (timResponseMessageIq_args_auth args)
      let res = default_TimResponseMessageIq_result{timResponseMessageIq_result_success = val}
      T.writeMessageBegin oprot ("timResponseMessageIq", T.M_REPLY, seqid)
      write_TimResponseMessageIq_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("timResponseMessageIq", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_timResponsePresenceList (seqid, iprot, oprot, handler) = do
  args <- read_TimResponsePresenceList_args iprot
  (X.catch
    (do
      val <- Iface.timResponsePresenceList handler (timResponsePresenceList_args_pbeanList args) (timResponsePresenceList_args_auth args)
      let res = default_TimResponsePresenceList_result{timResponsePresenceList_result_success = val}
      T.writeMessageBegin oprot ("timResponsePresenceList", T.M_REPLY, seqid)
      write_TimResponsePresenceList_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("timResponsePresenceList", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
process_timResponseMessageList (seqid, iprot, oprot, handler) = do
  args <- read_TimResponseMessageList_args iprot
  (X.catch
    (do
      val <- Iface.timResponseMessageList handler (timResponseMessageList_args_mbeanList args) (timResponseMessageList_args_auth args)
      let res = default_TimResponseMessageList_result{timResponseMessageList_result_success = val}
      T.writeMessageBegin oprot ("timResponseMessageList", T.M_REPLY, seqid)
      write_TimResponseMessageList_result oprot res
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot))
    ((\_ -> do
      T.writeMessageBegin oprot ("timResponseMessageList", T.M_EXCEPTION, seqid)
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")
      T.writeMessageEnd oprot
      T.tFlush (T.getTransport oprot)) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "timStream" -> process_timStream (seqid,iprot,oprot,handler)
  "timStarttls" -> process_timStarttls (seqid,iprot,oprot,handler)
  "timLogin" -> process_timLogin (seqid,iprot,oprot,handler)
  "timAck" -> process_timAck (seqid,iprot,oprot,handler)
  "timPresence" -> process_timPresence (seqid,iprot,oprot,handler)
  "timMessage" -> process_timMessage (seqid,iprot,oprot,handler)
  "timPing" -> process_timPing (seqid,iprot,oprot,handler)
  "timError" -> process_timError (seqid,iprot,oprot,handler)
  "timLogout" -> process_timLogout (seqid,iprot,oprot,handler)
  "timRegist" -> process_timRegist (seqid,iprot,oprot,handler)
  "timRoser" -> process_timRoser (seqid,iprot,oprot,handler)
  "timMessageList" -> process_timMessageList (seqid,iprot,oprot,handler)
  "timPresenceList" -> process_timPresenceList (seqid,iprot,oprot,handler)
  "timMessageIq" -> process_timMessageIq (seqid,iprot,oprot,handler)
  "timMessageResult" -> process_timMessageResult (seqid,iprot,oprot,handler)
  "timProperty" -> process_timProperty (seqid,iprot,oprot,handler)
  "timRemoteUserAuth" -> process_timRemoteUserAuth (seqid,iprot,oprot,handler)
  "timRemoteUserGet" -> process_timRemoteUserGet (seqid,iprot,oprot,handler)
  "timRemoteUserEdit" -> process_timRemoteUserEdit (seqid,iprot,oprot,handler)
  "timResponsePresence" -> process_timResponsePresence (seqid,iprot,oprot,handler)
  "timResponseMessage" -> process_timResponseMessage (seqid,iprot,oprot,handler)
  "timResponseMessageIq" -> process_timResponseMessageIq (seqid,iprot,oprot,handler)
  "timResponsePresenceList" -> process_timResponsePresenceList (seqid,iprot,oprot,handler)
  "timResponseMessageList" -> process_timResponseMessageList (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessageBegin oprot (name,T.M_EXCEPTION,seqid)
    T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
    T.writeMessageEnd oprot
    T.tFlush (T.getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- T.readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  T.readMessageEnd iprot
  P.return P.True
