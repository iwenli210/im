{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.3)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Tim_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


data TimError = TimError  { timError_errCode :: P.Maybe I.Int32
  , timError_errMsg :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimError where
  hashWithSalt salt record = salt   `H.hashWithSalt` timError_errCode record   `H.hashWithSalt` timError_errMsg record  
instance QC.Arbitrary TimError where 
  arbitrary = M.liftM TimError (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimError = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimError{timError_errCode = timError_errCode obj} then P.Nothing else P.Just $ default_TimError{timError_errCode = timError_errCode obj}
    , if obj == default_TimError{timError_errMsg = timError_errMsg obj} then P.Nothing else P.Just $ default_TimError{timError_errMsg = timError_errMsg obj}
    ]
from_TimError :: TimError -> T.ThriftVal
from_TimError record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> (1, ("errCode",T.TI32 _v2))) <$> timError_errCode record
  , (\_v2 -> (2, ("errMsg",T.TString $ E.encodeUtf8 _v2))) <$> timError_errMsg record
  ]
write_TimError :: (T.Protocol p, T.Transport t) => p t -> TimError -> P.IO ()
write_TimError oprot record = T.writeVal oprot $ from_TimError record
encode_TimError :: (T.Protocol p, T.Transport t) => p t -> TimError -> LBS.ByteString
encode_TimError oprot record = T.serializeVal oprot $ from_TimError record
to_TimError :: T.ThriftVal -> TimError
to_TimError (T.TStruct fields) = TimError{
  timError_errCode = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TI32 _val5 -> _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timError_errMsg = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TString _val6 -> E.decodeUtf8 _val6; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TimError _ = P.error "not a struct"
read_TimError :: (T.Transport t, T.Protocol p) => p t -> P.IO TimError
read_TimError iprot = to_TimError <$> T.readVal iprot (T.T_STRUCT typemap_TimError)
decode_TimError :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimError
decode_TimError iprot bs = to_TimError $ T.deserializeVal iprot (T.T_STRUCT typemap_TimError) bs
typemap_TimError :: T.TypeMap
typemap_TimError = Map.fromList [(1,("errCode",T.T_I32)),(2,("errMsg",T.T_STRING))]
default_TimError :: TimError
default_TimError = TimError{
  timError_errCode = P.Nothing,
  timError_errMsg = P.Nothing}
data TimNode = TimNode  { timNode_key :: P.Maybe LT.Text
  , timNode_value :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimNode where
  hashWithSalt salt record = salt   `H.hashWithSalt` timNode_key record   `H.hashWithSalt` timNode_value record  
instance QC.Arbitrary TimNode where 
  arbitrary = M.liftM TimNode (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimNode = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimNode{timNode_key = timNode_key obj} then P.Nothing else P.Just $ default_TimNode{timNode_key = timNode_key obj}
    , if obj == default_TimNode{timNode_value = timNode_value obj} then P.Nothing else P.Just $ default_TimNode{timNode_value = timNode_value obj}
    ]
from_TimNode :: TimNode -> T.ThriftVal
from_TimNode record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9 -> (1, ("key",T.TString $ E.encodeUtf8 _v9))) <$> timNode_key record
  , (\_v9 -> (2, ("value",T.TString $ E.encodeUtf8 _v9))) <$> timNode_value record
  ]
write_TimNode :: (T.Protocol p, T.Transport t) => p t -> TimNode -> P.IO ()
write_TimNode oprot record = T.writeVal oprot $ from_TimNode record
encode_TimNode :: (T.Protocol p, T.Transport t) => p t -> TimNode -> LBS.ByteString
encode_TimNode oprot record = T.serializeVal oprot $ from_TimNode record
to_TimNode :: T.ThriftVal -> TimNode
to_TimNode (T.TStruct fields) = TimNode{
  timNode_key = P.maybe (P.Nothing) (\(_,_val11) -> P.Just (case _val11 of {T.TString _val12 -> E.decodeUtf8 _val12; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timNode_value = P.maybe (P.Nothing) (\(_,_val11) -> P.Just (case _val11 of {T.TString _val13 -> E.decodeUtf8 _val13; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TimNode _ = P.error "not a struct"
read_TimNode :: (T.Transport t, T.Protocol p) => p t -> P.IO TimNode
read_TimNode iprot = to_TimNode <$> T.readVal iprot (T.T_STRUCT typemap_TimNode)
decode_TimNode :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimNode
decode_TimNode iprot bs = to_TimNode $ T.deserializeVal iprot (T.T_STRUCT typemap_TimNode) bs
typemap_TimNode :: T.TypeMap
typemap_TimNode = Map.fromList [(1,("key",T.T_STRING)),(2,("value",T.T_STRING))]
default_TimNode :: TimNode
default_TimNode = TimNode{
  timNode_key = P.Nothing,
  timNode_value = P.Nothing}
data TimAckBean = TimAckBean  { timAckBean_id :: P.Maybe LT.Text
  , timAckBean_ackType :: P.Maybe LT.Text
  , timAckBean_ackStatus :: P.Maybe LT.Text
  , timAckBean_extraList :: P.Maybe (Vector.Vector TimNode)
  , timAckBean_err :: P.Maybe TimError
  , timAckBean_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimAckBean where
  hashWithSalt salt record = salt   `H.hashWithSalt` timAckBean_id record   `H.hashWithSalt` timAckBean_ackType record   `H.hashWithSalt` timAckBean_ackStatus record   `H.hashWithSalt` timAckBean_extraList record   `H.hashWithSalt` timAckBean_err record   `H.hashWithSalt` timAckBean_extraMap record  
instance QC.Arbitrary TimAckBean where 
  arbitrary = M.liftM TimAckBean (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimAckBean = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimAckBean{timAckBean_id = timAckBean_id obj} then P.Nothing else P.Just $ default_TimAckBean{timAckBean_id = timAckBean_id obj}
    , if obj == default_TimAckBean{timAckBean_ackType = timAckBean_ackType obj} then P.Nothing else P.Just $ default_TimAckBean{timAckBean_ackType = timAckBean_ackType obj}
    , if obj == default_TimAckBean{timAckBean_ackStatus = timAckBean_ackStatus obj} then P.Nothing else P.Just $ default_TimAckBean{timAckBean_ackStatus = timAckBean_ackStatus obj}
    , if obj == default_TimAckBean{timAckBean_extraList = timAckBean_extraList obj} then P.Nothing else P.Just $ default_TimAckBean{timAckBean_extraList = timAckBean_extraList obj}
    , if obj == default_TimAckBean{timAckBean_err = timAckBean_err obj} then P.Nothing else P.Just $ default_TimAckBean{timAckBean_err = timAckBean_err obj}
    , if obj == default_TimAckBean{timAckBean_extraMap = timAckBean_extraMap obj} then P.Nothing else P.Just $ default_TimAckBean{timAckBean_extraMap = timAckBean_extraMap obj}
    ]
from_TimAckBean :: TimAckBean -> T.ThriftVal
from_TimAckBean record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v16 -> (1, ("id",T.TString $ E.encodeUtf8 _v16))) <$> timAckBean_id record
  , (\_v16 -> (2, ("ackType",T.TString $ E.encodeUtf8 _v16))) <$> timAckBean_ackType record
  , (\_v16 -> (3, ("ackStatus",T.TString $ E.encodeUtf8 _v16))) <$> timAckBean_ackStatus record
  , (\_v16 -> (4, ("extraList",T.TList (T.T_STRUCT typemap_TimNode) $ P.map (\_v18 -> from_TimNode _v18) $ Vector.toList _v16))) <$> timAckBean_extraList record
  , (\_v16 -> (5, ("err",from_TimError _v16))) <$> timAckBean_err record
  , (\_v16 -> (6, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k19,_v20) -> (T.TString $ E.encodeUtf8 _k19, T.TString $ E.encodeUtf8 _v20)) $ Map.toList _v16))) <$> timAckBean_extraMap record
  ]
write_TimAckBean :: (T.Protocol p, T.Transport t) => p t -> TimAckBean -> P.IO ()
write_TimAckBean oprot record = T.writeVal oprot $ from_TimAckBean record
encode_TimAckBean :: (T.Protocol p, T.Transport t) => p t -> TimAckBean -> LBS.ByteString
encode_TimAckBean oprot record = T.serializeVal oprot $ from_TimAckBean record
to_TimAckBean :: T.ThriftVal -> TimAckBean
to_TimAckBean (T.TStruct fields) = TimAckBean{
  timAckBean_id = P.maybe (P.Nothing) (\(_,_val22) -> P.Just (case _val22 of {T.TString _val23 -> E.decodeUtf8 _val23; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timAckBean_ackType = P.maybe (P.Nothing) (\(_,_val22) -> P.Just (case _val22 of {T.TString _val24 -> E.decodeUtf8 _val24; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timAckBean_ackStatus = P.maybe (P.Nothing) (\(_,_val22) -> P.Just (case _val22 of {T.TString _val25 -> E.decodeUtf8 _val25; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  timAckBean_extraList = P.maybe (P.Nothing) (\(_,_val22) -> P.Just (case _val22 of {T.TList _ _val26 -> (Vector.fromList $ P.map (\_v27 -> (case _v27 of {T.TStruct _val28 -> (to_TimNode (T.TStruct _val28)); _ -> P.error "wrong type"})) _val26); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  timAckBean_err = P.maybe (P.Nothing) (\(_,_val22) -> P.Just (case _val22 of {T.TStruct _val29 -> (to_TimError (T.TStruct _val29)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  timAckBean_extraMap = P.maybe (P.Nothing) (\(_,_val22) -> P.Just (case _val22 of {T.TMap _ _ _val30 -> (Map.fromList $ P.map (\(_k32,_v31) -> ((case _k32 of {T.TString _val33 -> E.decodeUtf8 _val33; _ -> P.error "wrong type"}),(case _v31 of {T.TString _val34 -> E.decodeUtf8 _val34; _ -> P.error "wrong type"}))) _val30); _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_TimAckBean _ = P.error "not a struct"
read_TimAckBean :: (T.Transport t, T.Protocol p) => p t -> P.IO TimAckBean
read_TimAckBean iprot = to_TimAckBean <$> T.readVal iprot (T.T_STRUCT typemap_TimAckBean)
decode_TimAckBean :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimAckBean
decode_TimAckBean iprot bs = to_TimAckBean $ T.deserializeVal iprot (T.T_STRUCT typemap_TimAckBean) bs
typemap_TimAckBean :: T.TypeMap
typemap_TimAckBean = Map.fromList [(1,("id",T.T_STRING)),(2,("ackType",T.T_STRING)),(3,("ackStatus",T.T_STRING)),(4,("extraList",(T.T_LIST (T.T_STRUCT typemap_TimNode)))),(5,("err",(T.T_STRUCT typemap_TimError))),(6,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TimAckBean :: TimAckBean
default_TimAckBean = TimAckBean{
  timAckBean_id = P.Nothing,
  timAckBean_ackType = P.Nothing,
  timAckBean_ackStatus = P.Nothing,
  timAckBean_extraList = P.Nothing,
  timAckBean_err = P.Nothing,
  timAckBean_extraMap = P.Nothing}
data TimHBean = TimHBean  { timHBean_chl :: I.Int32
  , timHBean_platform :: P.Maybe I.Int32
  , timHBean_version :: I.Int16
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimHBean where
  hashWithSalt salt record = salt   `H.hashWithSalt` timHBean_chl record   `H.hashWithSalt` timHBean_platform record   `H.hashWithSalt` timHBean_version record  
instance QC.Arbitrary TimHBean where 
  arbitrary = M.liftM TimHBean (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TimHBean = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimHBean{timHBean_chl = timHBean_chl obj} then P.Nothing else P.Just $ default_TimHBean{timHBean_chl = timHBean_chl obj}
    , if obj == default_TimHBean{timHBean_platform = timHBean_platform obj} then P.Nothing else P.Just $ default_TimHBean{timHBean_platform = timHBean_platform obj}
    , if obj == default_TimHBean{timHBean_version = timHBean_version obj} then P.Nothing else P.Just $ default_TimHBean{timHBean_version = timHBean_version obj}
    ]
from_TimHBean :: TimHBean -> T.ThriftVal
from_TimHBean record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v37 -> P.Just (1, ("chl",T.TI32 _v37))) $ timHBean_chl record
  , (\_v37 -> (2, ("platform",T.TI32 _v37))) <$> timHBean_platform record
  , (\_v37 -> P.Just (3, ("version",T.TI16 _v37))) $ timHBean_version record
  ]
write_TimHBean :: (T.Protocol p, T.Transport t) => p t -> TimHBean -> P.IO ()
write_TimHBean oprot record = T.writeVal oprot $ from_TimHBean record
encode_TimHBean :: (T.Protocol p, T.Transport t) => p t -> TimHBean -> LBS.ByteString
encode_TimHBean oprot record = T.serializeVal oprot $ from_TimHBean record
to_TimHBean :: T.ThriftVal -> TimHBean
to_TimHBean (T.TStruct fields) = TimHBean{
  timHBean_chl = P.maybe (P.error "Missing required field: chl") (\(_,_val39) -> (case _val39 of {T.TI32 _val40 -> _val40; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timHBean_platform = P.maybe (P.Nothing) (\(_,_val39) -> P.Just (case _val39 of {T.TI32 _val41 -> _val41; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timHBean_version = P.maybe (P.error "Missing required field: version") (\(_,_val39) -> (case _val39 of {T.TI16 _val42 -> _val42; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_TimHBean _ = P.error "not a struct"
read_TimHBean :: (T.Transport t, T.Protocol p) => p t -> P.IO TimHBean
read_TimHBean iprot = to_TimHBean <$> T.readVal iprot (T.T_STRUCT typemap_TimHBean)
decode_TimHBean :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimHBean
decode_TimHBean iprot bs = to_TimHBean $ T.deserializeVal iprot (T.T_STRUCT typemap_TimHBean) bs
typemap_TimHBean :: T.TypeMap
typemap_TimHBean = Map.fromList [(1,("chl",T.T_I32)),(2,("platform",T.T_I32)),(3,("version",T.T_I16))]
default_TimHBean :: TimHBean
default_TimHBean = TimHBean{
  timHBean_chl = 0,
  timHBean_platform = P.Nothing,
  timHBean_version = 0}
data TimParam = TimParam  { timParam_timestamp :: P.Maybe LT.Text
  , timParam_version :: P.Maybe I.Int16
  , timParam_lang :: P.Maybe LT.Text
  , timParam_extraList :: P.Maybe (Vector.Vector TimNode)
  , timParam_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  , timParam_interflow :: P.Maybe LT.Text
  , timParam_tls :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimParam where
  hashWithSalt salt record = salt   `H.hashWithSalt` timParam_timestamp record   `H.hashWithSalt` timParam_version record   `H.hashWithSalt` timParam_lang record   `H.hashWithSalt` timParam_extraList record   `H.hashWithSalt` timParam_extraMap record   `H.hashWithSalt` timParam_interflow record   `H.hashWithSalt` timParam_tls record  
instance QC.Arbitrary TimParam where 
  arbitrary = M.liftM TimParam (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimParam = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimParam{timParam_timestamp = timParam_timestamp obj} then P.Nothing else P.Just $ default_TimParam{timParam_timestamp = timParam_timestamp obj}
    , if obj == default_TimParam{timParam_version = timParam_version obj} then P.Nothing else P.Just $ default_TimParam{timParam_version = timParam_version obj}
    , if obj == default_TimParam{timParam_lang = timParam_lang obj} then P.Nothing else P.Just $ default_TimParam{timParam_lang = timParam_lang obj}
    , if obj == default_TimParam{timParam_extraList = timParam_extraList obj} then P.Nothing else P.Just $ default_TimParam{timParam_extraList = timParam_extraList obj}
    , if obj == default_TimParam{timParam_extraMap = timParam_extraMap obj} then P.Nothing else P.Just $ default_TimParam{timParam_extraMap = timParam_extraMap obj}
    , if obj == default_TimParam{timParam_interflow = timParam_interflow obj} then P.Nothing else P.Just $ default_TimParam{timParam_interflow = timParam_interflow obj}
    , if obj == default_TimParam{timParam_tls = timParam_tls obj} then P.Nothing else P.Just $ default_TimParam{timParam_tls = timParam_tls obj}
    ]
from_TimParam :: TimParam -> T.ThriftVal
from_TimParam record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v45 -> (1, ("timestamp",T.TString $ E.encodeUtf8 _v45))) <$> timParam_timestamp record
  , (\_v45 -> (2, ("version",T.TI16 _v45))) <$> timParam_version record
  , (\_v45 -> (3, ("lang",T.TString $ E.encodeUtf8 _v45))) <$> timParam_lang record
  , (\_v45 -> (4, ("extraList",T.TList (T.T_STRUCT typemap_TimNode) $ P.map (\_v47 -> from_TimNode _v47) $ Vector.toList _v45))) <$> timParam_extraList record
  , (\_v45 -> (5, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k48,_v49) -> (T.TString $ E.encodeUtf8 _k48, T.TString $ E.encodeUtf8 _v49)) $ Map.toList _v45))) <$> timParam_extraMap record
  , (\_v45 -> (6, ("interflow",T.TString $ E.encodeUtf8 _v45))) <$> timParam_interflow record
  , (\_v45 -> (7, ("tls",T.TString $ E.encodeUtf8 _v45))) <$> timParam_tls record
  ]
write_TimParam :: (T.Protocol p, T.Transport t) => p t -> TimParam -> P.IO ()
write_TimParam oprot record = T.writeVal oprot $ from_TimParam record
encode_TimParam :: (T.Protocol p, T.Transport t) => p t -> TimParam -> LBS.ByteString
encode_TimParam oprot record = T.serializeVal oprot $ from_TimParam record
to_TimParam :: T.ThriftVal -> TimParam
to_TimParam (T.TStruct fields) = TimParam{
  timParam_timestamp = P.maybe (P.Nothing) (\(_,_val51) -> P.Just (case _val51 of {T.TString _val52 -> E.decodeUtf8 _val52; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timParam_version = P.maybe (P.Nothing) (\(_,_val51) -> P.Just (case _val51 of {T.TI16 _val53 -> _val53; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timParam_lang = P.maybe (P.Nothing) (\(_,_val51) -> P.Just (case _val51 of {T.TString _val54 -> E.decodeUtf8 _val54; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  timParam_extraList = P.maybe (P.Nothing) (\(_,_val51) -> P.Just (case _val51 of {T.TList _ _val55 -> (Vector.fromList $ P.map (\_v56 -> (case _v56 of {T.TStruct _val57 -> (to_TimNode (T.TStruct _val57)); _ -> P.error "wrong type"})) _val55); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  timParam_extraMap = P.maybe (P.Nothing) (\(_,_val51) -> P.Just (case _val51 of {T.TMap _ _ _val58 -> (Map.fromList $ P.map (\(_k60,_v59) -> ((case _k60 of {T.TString _val61 -> E.decodeUtf8 _val61; _ -> P.error "wrong type"}),(case _v59 of {T.TString _val62 -> E.decodeUtf8 _val62; _ -> P.error "wrong type"}))) _val58); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  timParam_interflow = P.maybe (P.Nothing) (\(_,_val51) -> P.Just (case _val51 of {T.TString _val63 -> E.decodeUtf8 _val63; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  timParam_tls = P.maybe (P.Nothing) (\(_,_val51) -> P.Just (case _val51 of {T.TString _val64 -> E.decodeUtf8 _val64; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_TimParam _ = P.error "not a struct"
read_TimParam :: (T.Transport t, T.Protocol p) => p t -> P.IO TimParam
read_TimParam iprot = to_TimParam <$> T.readVal iprot (T.T_STRUCT typemap_TimParam)
decode_TimParam :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimParam
decode_TimParam iprot bs = to_TimParam $ T.deserializeVal iprot (T.T_STRUCT typemap_TimParam) bs
typemap_TimParam :: T.TypeMap
typemap_TimParam = Map.fromList [(1,("timestamp",T.T_STRING)),(2,("version",T.T_I16)),(3,("lang",T.T_STRING)),(4,("extraList",(T.T_LIST (T.T_STRUCT typemap_TimNode)))),(5,("extraMap",(T.T_MAP T.T_STRING T.T_STRING))),(6,("interflow",T.T_STRING)),(7,("tls",T.T_STRING))]
default_TimParam :: TimParam
default_TimParam = TimParam{
  timParam_timestamp = P.Nothing,
  timParam_version = P.Nothing,
  timParam_lang = P.Nothing,
  timParam_extraList = P.Nothing,
  timParam_extraMap = P.Nothing,
  timParam_interflow = P.Nothing,
  timParam_tls = P.Nothing}
data TimTime = TimTime  { timTime_timestamp :: P.Maybe LT.Text
  , timTime_formattime :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimTime where
  hashWithSalt salt record = salt   `H.hashWithSalt` timTime_timestamp record   `H.hashWithSalt` timTime_formattime record  
instance QC.Arbitrary TimTime where 
  arbitrary = M.liftM TimTime (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimTime = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimTime{timTime_timestamp = timTime_timestamp obj} then P.Nothing else P.Just $ default_TimTime{timTime_timestamp = timTime_timestamp obj}
    , if obj == default_TimTime{timTime_formattime = timTime_formattime obj} then P.Nothing else P.Just $ default_TimTime{timTime_formattime = timTime_formattime obj}
    ]
from_TimTime :: TimTime -> T.ThriftVal
from_TimTime record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v67 -> (1, ("timestamp",T.TString $ E.encodeUtf8 _v67))) <$> timTime_timestamp record
  , (\_v67 -> (2, ("formattime",T.TString $ E.encodeUtf8 _v67))) <$> timTime_formattime record
  ]
write_TimTime :: (T.Protocol p, T.Transport t) => p t -> TimTime -> P.IO ()
write_TimTime oprot record = T.writeVal oprot $ from_TimTime record
encode_TimTime :: (T.Protocol p, T.Transport t) => p t -> TimTime -> LBS.ByteString
encode_TimTime oprot record = T.serializeVal oprot $ from_TimTime record
to_TimTime :: T.ThriftVal -> TimTime
to_TimTime (T.TStruct fields) = TimTime{
  timTime_timestamp = P.maybe (P.Nothing) (\(_,_val69) -> P.Just (case _val69 of {T.TString _val70 -> E.decodeUtf8 _val70; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timTime_formattime = P.maybe (P.Nothing) (\(_,_val69) -> P.Just (case _val69 of {T.TString _val71 -> E.decodeUtf8 _val71; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TimTime _ = P.error "not a struct"
read_TimTime :: (T.Transport t, T.Protocol p) => p t -> P.IO TimTime
read_TimTime iprot = to_TimTime <$> T.readVal iprot (T.T_STRUCT typemap_TimTime)
decode_TimTime :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimTime
decode_TimTime iprot bs = to_TimTime $ T.deserializeVal iprot (T.T_STRUCT typemap_TimTime) bs
typemap_TimTime :: T.TypeMap
typemap_TimTime = Map.fromList [(1,("timestamp",T.T_STRING)),(2,("formattime",T.T_STRING))]
default_TimTime :: TimTime
default_TimTime = TimTime{
  timTime_timestamp = P.Nothing,
  timTime_formattime = P.Nothing}
data TimArea = TimArea  { timArea_country :: P.Maybe LT.Text
  , timArea_province :: P.Maybe LT.Text
  , timArea_city :: P.Maybe LT.Text
  , timArea_extraList :: P.Maybe (Vector.Vector TimNode)
  , timArea_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimArea where
  hashWithSalt salt record = salt   `H.hashWithSalt` timArea_country record   `H.hashWithSalt` timArea_province record   `H.hashWithSalt` timArea_city record   `H.hashWithSalt` timArea_extraList record   `H.hashWithSalt` timArea_extraMap record  
instance QC.Arbitrary TimArea where 
  arbitrary = M.liftM TimArea (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimArea = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimArea{timArea_country = timArea_country obj} then P.Nothing else P.Just $ default_TimArea{timArea_country = timArea_country obj}
    , if obj == default_TimArea{timArea_province = timArea_province obj} then P.Nothing else P.Just $ default_TimArea{timArea_province = timArea_province obj}
    , if obj == default_TimArea{timArea_city = timArea_city obj} then P.Nothing else P.Just $ default_TimArea{timArea_city = timArea_city obj}
    , if obj == default_TimArea{timArea_extraList = timArea_extraList obj} then P.Nothing else P.Just $ default_TimArea{timArea_extraList = timArea_extraList obj}
    , if obj == default_TimArea{timArea_extraMap = timArea_extraMap obj} then P.Nothing else P.Just $ default_TimArea{timArea_extraMap = timArea_extraMap obj}
    ]
from_TimArea :: TimArea -> T.ThriftVal
from_TimArea record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v74 -> (1, ("country",T.TString $ E.encodeUtf8 _v74))) <$> timArea_country record
  , (\_v74 -> (2, ("province",T.TString $ E.encodeUtf8 _v74))) <$> timArea_province record
  , (\_v74 -> (3, ("city",T.TString $ E.encodeUtf8 _v74))) <$> timArea_city record
  , (\_v74 -> (4, ("extraList",T.TList (T.T_STRUCT typemap_TimNode) $ P.map (\_v76 -> from_TimNode _v76) $ Vector.toList _v74))) <$> timArea_extraList record
  , (\_v74 -> (5, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k77,_v78) -> (T.TString $ E.encodeUtf8 _k77, T.TString $ E.encodeUtf8 _v78)) $ Map.toList _v74))) <$> timArea_extraMap record
  ]
write_TimArea :: (T.Protocol p, T.Transport t) => p t -> TimArea -> P.IO ()
write_TimArea oprot record = T.writeVal oprot $ from_TimArea record
encode_TimArea :: (T.Protocol p, T.Transport t) => p t -> TimArea -> LBS.ByteString
encode_TimArea oprot record = T.serializeVal oprot $ from_TimArea record
to_TimArea :: T.ThriftVal -> TimArea
to_TimArea (T.TStruct fields) = TimArea{
  timArea_country = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TString _val81 -> E.decodeUtf8 _val81; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timArea_province = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TString _val82 -> E.decodeUtf8 _val82; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timArea_city = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TString _val83 -> E.decodeUtf8 _val83; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  timArea_extraList = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TList _ _val84 -> (Vector.fromList $ P.map (\_v85 -> (case _v85 of {T.TStruct _val86 -> (to_TimNode (T.TStruct _val86)); _ -> P.error "wrong type"})) _val84); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  timArea_extraMap = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TMap _ _ _val87 -> (Map.fromList $ P.map (\(_k89,_v88) -> ((case _k89 of {T.TString _val90 -> E.decodeUtf8 _val90; _ -> P.error "wrong type"}),(case _v88 of {T.TString _val91 -> E.decodeUtf8 _val91; _ -> P.error "wrong type"}))) _val87); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_TimArea _ = P.error "not a struct"
read_TimArea :: (T.Transport t, T.Protocol p) => p t -> P.IO TimArea
read_TimArea iprot = to_TimArea <$> T.readVal iprot (T.T_STRUCT typemap_TimArea)
decode_TimArea :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimArea
decode_TimArea iprot bs = to_TimArea $ T.deserializeVal iprot (T.T_STRUCT typemap_TimArea) bs
typemap_TimArea :: T.TypeMap
typemap_TimArea = Map.fromList [(1,("country",T.T_STRING)),(2,("province",T.T_STRING)),(3,("city",T.T_STRING)),(4,("extraList",(T.T_LIST (T.T_STRUCT typemap_TimNode)))),(5,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TimArea :: TimArea
default_TimArea = TimArea{
  timArea_country = P.Nothing,
  timArea_province = P.Nothing,
  timArea_city = P.Nothing,
  timArea_extraList = P.Nothing,
  timArea_extraMap = P.Nothing}
data Tid = Tid  { tid_name :: LT.Text
  , tid_domain :: P.Maybe LT.Text
  , tid_resource :: P.Maybe LT.Text
  , tid_type :: P.Maybe LT.Text
  , tid_extraList :: P.Maybe (Vector.Vector TimNode)
  , tid_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Tid where
  hashWithSalt salt record = salt   `H.hashWithSalt` tid_name record   `H.hashWithSalt` tid_domain record   `H.hashWithSalt` tid_resource record   `H.hashWithSalt` tid_type record   `H.hashWithSalt` tid_extraList record   `H.hashWithSalt` tid_extraMap record  
instance QC.Arbitrary Tid where 
  arbitrary = M.liftM Tid (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Tid = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Tid{tid_name = tid_name obj} then P.Nothing else P.Just $ default_Tid{tid_name = tid_name obj}
    , if obj == default_Tid{tid_domain = tid_domain obj} then P.Nothing else P.Just $ default_Tid{tid_domain = tid_domain obj}
    , if obj == default_Tid{tid_resource = tid_resource obj} then P.Nothing else P.Just $ default_Tid{tid_resource = tid_resource obj}
    , if obj == default_Tid{tid_type = tid_type obj} then P.Nothing else P.Just $ default_Tid{tid_type = tid_type obj}
    , if obj == default_Tid{tid_extraList = tid_extraList obj} then P.Nothing else P.Just $ default_Tid{tid_extraList = tid_extraList obj}
    , if obj == default_Tid{tid_extraMap = tid_extraMap obj} then P.Nothing else P.Just $ default_Tid{tid_extraMap = tid_extraMap obj}
    ]
from_Tid :: Tid -> T.ThriftVal
from_Tid record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v94 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v94))) $ tid_name record
  , (\_v94 -> (2, ("domain",T.TString $ E.encodeUtf8 _v94))) <$> tid_domain record
  , (\_v94 -> (3, ("resource",T.TString $ E.encodeUtf8 _v94))) <$> tid_resource record
  , (\_v94 -> (4, ("type",T.TString $ E.encodeUtf8 _v94))) <$> tid_type record
  , (\_v94 -> (5, ("extraList",T.TList (T.T_STRUCT typemap_TimNode) $ P.map (\_v96 -> from_TimNode _v96) $ Vector.toList _v94))) <$> tid_extraList record
  , (\_v94 -> (6, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k97,_v98) -> (T.TString $ E.encodeUtf8 _k97, T.TString $ E.encodeUtf8 _v98)) $ Map.toList _v94))) <$> tid_extraMap record
  ]
write_Tid :: (T.Protocol p, T.Transport t) => p t -> Tid -> P.IO ()
write_Tid oprot record = T.writeVal oprot $ from_Tid record
encode_Tid :: (T.Protocol p, T.Transport t) => p t -> Tid -> LBS.ByteString
encode_Tid oprot record = T.serializeVal oprot $ from_Tid record
to_Tid :: T.ThriftVal -> Tid
to_Tid (T.TStruct fields) = Tid{
  tid_name = P.maybe (P.error "Missing required field: name") (\(_,_val100) -> (case _val100 of {T.TString _val101 -> E.decodeUtf8 _val101; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tid_domain = P.maybe (P.Nothing) (\(_,_val100) -> P.Just (case _val100 of {T.TString _val102 -> E.decodeUtf8 _val102; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  tid_resource = P.maybe (P.Nothing) (\(_,_val100) -> P.Just (case _val100 of {T.TString _val103 -> E.decodeUtf8 _val103; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  tid_type = P.maybe (P.Nothing) (\(_,_val100) -> P.Just (case _val100 of {T.TString _val104 -> E.decodeUtf8 _val104; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  tid_extraList = P.maybe (P.Nothing) (\(_,_val100) -> P.Just (case _val100 of {T.TList _ _val105 -> (Vector.fromList $ P.map (\_v106 -> (case _v106 of {T.TStruct _val107 -> (to_TimNode (T.TStruct _val107)); _ -> P.error "wrong type"})) _val105); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  tid_extraMap = P.maybe (P.Nothing) (\(_,_val100) -> P.Just (case _val100 of {T.TMap _ _ _val108 -> (Map.fromList $ P.map (\(_k110,_v109) -> ((case _k110 of {T.TString _val111 -> E.decodeUtf8 _val111; _ -> P.error "wrong type"}),(case _v109 of {T.TString _val112 -> E.decodeUtf8 _val112; _ -> P.error "wrong type"}))) _val108); _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_Tid _ = P.error "not a struct"
read_Tid :: (T.Transport t, T.Protocol p) => p t -> P.IO Tid
read_Tid iprot = to_Tid <$> T.readVal iprot (T.T_STRUCT typemap_Tid)
decode_Tid :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> Tid
decode_Tid iprot bs = to_Tid $ T.deserializeVal iprot (T.T_STRUCT typemap_Tid) bs
typemap_Tid :: T.TypeMap
typemap_Tid = Map.fromList [(1,("name",T.T_STRING)),(2,("domain",T.T_STRING)),(3,("resource",T.T_STRING)),(4,("type",T.T_STRING)),(5,("extraList",(T.T_LIST (T.T_STRUCT typemap_TimNode)))),(6,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_Tid :: Tid
default_Tid = Tid{
  tid_name = "",
  tid_domain = P.Nothing,
  tid_resource = P.Nothing,
  tid_type = P.Nothing,
  tid_extraList = P.Nothing,
  tid_extraMap = P.Nothing}
data TimUserBean = TimUserBean  { timUserBean_tid :: P.Maybe Tid
  , timUserBean_nickname :: P.Maybe LT.Text
  , timUserBean_remarkname :: P.Maybe LT.Text
  , timUserBean_brithday :: P.Maybe LT.Text
  , timUserBean_gender :: P.Maybe I.Int16
  , timUserBean_headurl :: P.Maybe LT.Text
  , timUserBean_area :: P.Maybe TimArea
  , timUserBean_headbyte :: P.Maybe LBS.ByteString
  , timUserBean_photoBytes :: P.Maybe (Vector.Vector LBS.ByteString)
  , timUserBean_extraList :: P.Maybe (Vector.Vector TimNode)
  , timUserBean_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimUserBean where
  hashWithSalt salt record = salt   `H.hashWithSalt` timUserBean_tid record   `H.hashWithSalt` timUserBean_nickname record   `H.hashWithSalt` timUserBean_remarkname record   `H.hashWithSalt` timUserBean_brithday record   `H.hashWithSalt` timUserBean_gender record   `H.hashWithSalt` timUserBean_headurl record   `H.hashWithSalt` timUserBean_area record   `H.hashWithSalt` timUserBean_headbyte record   `H.hashWithSalt` timUserBean_photoBytes record   `H.hashWithSalt` timUserBean_extraList record   `H.hashWithSalt` timUserBean_extraMap record  
instance QC.Arbitrary TimUserBean where 
  arbitrary = M.liftM TimUserBean (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimUserBean = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimUserBean{timUserBean_tid = timUserBean_tid obj} then P.Nothing else P.Just $ default_TimUserBean{timUserBean_tid = timUserBean_tid obj}
    , if obj == default_TimUserBean{timUserBean_nickname = timUserBean_nickname obj} then P.Nothing else P.Just $ default_TimUserBean{timUserBean_nickname = timUserBean_nickname obj}
    , if obj == default_TimUserBean{timUserBean_remarkname = timUserBean_remarkname obj} then P.Nothing else P.Just $ default_TimUserBean{timUserBean_remarkname = timUserBean_remarkname obj}
    , if obj == default_TimUserBean{timUserBean_brithday = timUserBean_brithday obj} then P.Nothing else P.Just $ default_TimUserBean{timUserBean_brithday = timUserBean_brithday obj}
    , if obj == default_TimUserBean{timUserBean_gender = timUserBean_gender obj} then P.Nothing else P.Just $ default_TimUserBean{timUserBean_gender = timUserBean_gender obj}
    , if obj == default_TimUserBean{timUserBean_headurl = timUserBean_headurl obj} then P.Nothing else P.Just $ default_TimUserBean{timUserBean_headurl = timUserBean_headurl obj}
    , if obj == default_TimUserBean{timUserBean_area = timUserBean_area obj} then P.Nothing else P.Just $ default_TimUserBean{timUserBean_area = timUserBean_area obj}
    , if obj == default_TimUserBean{timUserBean_headbyte = timUserBean_headbyte obj} then P.Nothing else P.Just $ default_TimUserBean{timUserBean_headbyte = timUserBean_headbyte obj}
    , if obj == default_TimUserBean{timUserBean_photoBytes = timUserBean_photoBytes obj} then P.Nothing else P.Just $ default_TimUserBean{timUserBean_photoBytes = timUserBean_photoBytes obj}
    , if obj == default_TimUserBean{timUserBean_extraList = timUserBean_extraList obj} then P.Nothing else P.Just $ default_TimUserBean{timUserBean_extraList = timUserBean_extraList obj}
    , if obj == default_TimUserBean{timUserBean_extraMap = timUserBean_extraMap obj} then P.Nothing else P.Just $ default_TimUserBean{timUserBean_extraMap = timUserBean_extraMap obj}
    ]
from_TimUserBean :: TimUserBean -> T.ThriftVal
from_TimUserBean record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v115 -> (1, ("tid",from_Tid _v115))) <$> timUserBean_tid record
  , (\_v115 -> (2, ("nickname",T.TString $ E.encodeUtf8 _v115))) <$> timUserBean_nickname record
  , (\_v115 -> (3, ("remarkname",T.TString $ E.encodeUtf8 _v115))) <$> timUserBean_remarkname record
  , (\_v115 -> (4, ("brithday",T.TString $ E.encodeUtf8 _v115))) <$> timUserBean_brithday record
  , (\_v115 -> (5, ("gender",T.TI16 _v115))) <$> timUserBean_gender record
  , (\_v115 -> (6, ("headurl",T.TString $ E.encodeUtf8 _v115))) <$> timUserBean_headurl record
  , (\_v115 -> (7, ("area",from_TimArea _v115))) <$> timUserBean_area record
  , (\_v115 -> (8, ("headbyte",T.TString _v115))) <$> timUserBean_headbyte record
  , (\_v115 -> (9, ("photoBytes",T.TList T.T_STRING $ P.map (\_v117 -> T.TString _v117) $ Vector.toList _v115))) <$> timUserBean_photoBytes record
  , (\_v115 -> (10, ("extraList",T.TList (T.T_STRUCT typemap_TimNode) $ P.map (\_v119 -> from_TimNode _v119) $ Vector.toList _v115))) <$> timUserBean_extraList record
  , (\_v115 -> (11, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k120,_v121) -> (T.TString $ E.encodeUtf8 _k120, T.TString $ E.encodeUtf8 _v121)) $ Map.toList _v115))) <$> timUserBean_extraMap record
  ]
write_TimUserBean :: (T.Protocol p, T.Transport t) => p t -> TimUserBean -> P.IO ()
write_TimUserBean oprot record = T.writeVal oprot $ from_TimUserBean record
encode_TimUserBean :: (T.Protocol p, T.Transport t) => p t -> TimUserBean -> LBS.ByteString
encode_TimUserBean oprot record = T.serializeVal oprot $ from_TimUserBean record
to_TimUserBean :: T.ThriftVal -> TimUserBean
to_TimUserBean (T.TStruct fields) = TimUserBean{
  timUserBean_tid = P.maybe (P.Nothing) (\(_,_val123) -> P.Just (case _val123 of {T.TStruct _val124 -> (to_Tid (T.TStruct _val124)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timUserBean_nickname = P.maybe (P.Nothing) (\(_,_val123) -> P.Just (case _val123 of {T.TString _val125 -> E.decodeUtf8 _val125; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timUserBean_remarkname = P.maybe (P.Nothing) (\(_,_val123) -> P.Just (case _val123 of {T.TString _val126 -> E.decodeUtf8 _val126; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  timUserBean_brithday = P.maybe (P.Nothing) (\(_,_val123) -> P.Just (case _val123 of {T.TString _val127 -> E.decodeUtf8 _val127; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  timUserBean_gender = P.maybe (P.Nothing) (\(_,_val123) -> P.Just (case _val123 of {T.TI16 _val128 -> _val128; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  timUserBean_headurl = P.maybe (P.Nothing) (\(_,_val123) -> P.Just (case _val123 of {T.TString _val129 -> E.decodeUtf8 _val129; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  timUserBean_area = P.maybe (P.Nothing) (\(_,_val123) -> P.Just (case _val123 of {T.TStruct _val130 -> (to_TimArea (T.TStruct _val130)); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  timUserBean_headbyte = P.maybe (P.Nothing) (\(_,_val123) -> P.Just (case _val123 of {T.TString _val131 -> _val131; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  timUserBean_photoBytes = P.maybe (P.Nothing) (\(_,_val123) -> P.Just (case _val123 of {T.TList _ _val132 -> (Vector.fromList $ P.map (\_v133 -> (case _v133 of {T.TString _val134 -> _val134; _ -> P.error "wrong type"})) _val132); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  timUserBean_extraList = P.maybe (P.Nothing) (\(_,_val123) -> P.Just (case _val123 of {T.TList _ _val135 -> (Vector.fromList $ P.map (\_v136 -> (case _v136 of {T.TStruct _val137 -> (to_TimNode (T.TStruct _val137)); _ -> P.error "wrong type"})) _val135); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  timUserBean_extraMap = P.maybe (P.Nothing) (\(_,_val123) -> P.Just (case _val123 of {T.TMap _ _ _val138 -> (Map.fromList $ P.map (\(_k140,_v139) -> ((case _k140 of {T.TString _val141 -> E.decodeUtf8 _val141; _ -> P.error "wrong type"}),(case _v139 of {T.TString _val142 -> E.decodeUtf8 _val142; _ -> P.error "wrong type"}))) _val138); _ -> P.error "wrong type"})) (Map.lookup (11) fields)
  }
to_TimUserBean _ = P.error "not a struct"
read_TimUserBean :: (T.Transport t, T.Protocol p) => p t -> P.IO TimUserBean
read_TimUserBean iprot = to_TimUserBean <$> T.readVal iprot (T.T_STRUCT typemap_TimUserBean)
decode_TimUserBean :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimUserBean
decode_TimUserBean iprot bs = to_TimUserBean $ T.deserializeVal iprot (T.T_STRUCT typemap_TimUserBean) bs
typemap_TimUserBean :: T.TypeMap
typemap_TimUserBean = Map.fromList [(1,("tid",(T.T_STRUCT typemap_Tid))),(2,("nickname",T.T_STRING)),(3,("remarkname",T.T_STRING)),(4,("brithday",T.T_STRING)),(5,("gender",T.T_I16)),(6,("headurl",T.T_STRING)),(7,("area",(T.T_STRUCT typemap_TimArea))),(8,("headbyte",T.T_STRING)),(9,("photoBytes",(T.T_LIST T.T_STRING))),(10,("extraList",(T.T_LIST (T.T_STRUCT typemap_TimNode)))),(11,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TimUserBean :: TimUserBean
default_TimUserBean = TimUserBean{
  timUserBean_tid = P.Nothing,
  timUserBean_nickname = P.Nothing,
  timUserBean_remarkname = P.Nothing,
  timUserBean_brithday = P.Nothing,
  timUserBean_gender = P.Nothing,
  timUserBean_headurl = P.Nothing,
  timUserBean_area = P.Nothing,
  timUserBean_headbyte = P.Nothing,
  timUserBean_photoBytes = P.Nothing,
  timUserBean_extraList = P.Nothing,
  timUserBean_extraMap = P.Nothing}
data TimRoom = TimRoom  { timRoom_tid :: P.Maybe Tid
  , timRoom_founderTid :: P.Maybe Tid
  , timRoom_HostsTid :: P.Maybe (Vector.Vector Tid)
  , timRoom_membersTid :: P.Maybe (Vector.Vector Tid)
  , timRoom_headurl :: P.Maybe LT.Text
  , timRoom_roomName :: P.Maybe LT.Text
  , timRoom_desc :: P.Maybe LT.Text
  , timRoom_createTime :: P.Maybe TimTime
  , timRoom_extraList :: P.Maybe (Vector.Vector TimNode)
  , timRoom_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimRoom where
  hashWithSalt salt record = salt   `H.hashWithSalt` timRoom_tid record   `H.hashWithSalt` timRoom_founderTid record   `H.hashWithSalt` timRoom_HostsTid record   `H.hashWithSalt` timRoom_membersTid record   `H.hashWithSalt` timRoom_headurl record   `H.hashWithSalt` timRoom_roomName record   `H.hashWithSalt` timRoom_desc record   `H.hashWithSalt` timRoom_createTime record   `H.hashWithSalt` timRoom_extraList record   `H.hashWithSalt` timRoom_extraMap record  
instance QC.Arbitrary TimRoom where 
  arbitrary = M.liftM TimRoom (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimRoom = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimRoom{timRoom_tid = timRoom_tid obj} then P.Nothing else P.Just $ default_TimRoom{timRoom_tid = timRoom_tid obj}
    , if obj == default_TimRoom{timRoom_founderTid = timRoom_founderTid obj} then P.Nothing else P.Just $ default_TimRoom{timRoom_founderTid = timRoom_founderTid obj}
    , if obj == default_TimRoom{timRoom_HostsTid = timRoom_HostsTid obj} then P.Nothing else P.Just $ default_TimRoom{timRoom_HostsTid = timRoom_HostsTid obj}
    , if obj == default_TimRoom{timRoom_membersTid = timRoom_membersTid obj} then P.Nothing else P.Just $ default_TimRoom{timRoom_membersTid = timRoom_membersTid obj}
    , if obj == default_TimRoom{timRoom_headurl = timRoom_headurl obj} then P.Nothing else P.Just $ default_TimRoom{timRoom_headurl = timRoom_headurl obj}
    , if obj == default_TimRoom{timRoom_roomName = timRoom_roomName obj} then P.Nothing else P.Just $ default_TimRoom{timRoom_roomName = timRoom_roomName obj}
    , if obj == default_TimRoom{timRoom_desc = timRoom_desc obj} then P.Nothing else P.Just $ default_TimRoom{timRoom_desc = timRoom_desc obj}
    , if obj == default_TimRoom{timRoom_createTime = timRoom_createTime obj} then P.Nothing else P.Just $ default_TimRoom{timRoom_createTime = timRoom_createTime obj}
    , if obj == default_TimRoom{timRoom_extraList = timRoom_extraList obj} then P.Nothing else P.Just $ default_TimRoom{timRoom_extraList = timRoom_extraList obj}
    , if obj == default_TimRoom{timRoom_extraMap = timRoom_extraMap obj} then P.Nothing else P.Just $ default_TimRoom{timRoom_extraMap = timRoom_extraMap obj}
    ]
from_TimRoom :: TimRoom -> T.ThriftVal
from_TimRoom record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v145 -> (1, ("tid",from_Tid _v145))) <$> timRoom_tid record
  , (\_v145 -> (2, ("founderTid",from_Tid _v145))) <$> timRoom_founderTid record
  , (\_v145 -> (3, ("HostsTid",T.TList (T.T_STRUCT typemap_Tid) $ P.map (\_v147 -> from_Tid _v147) $ Vector.toList _v145))) <$> timRoom_HostsTid record
  , (\_v145 -> (4, ("membersTid",T.TList (T.T_STRUCT typemap_Tid) $ P.map (\_v149 -> from_Tid _v149) $ Vector.toList _v145))) <$> timRoom_membersTid record
  , (\_v145 -> (5, ("headurl",T.TString $ E.encodeUtf8 _v145))) <$> timRoom_headurl record
  , (\_v145 -> (6, ("roomName",T.TString $ E.encodeUtf8 _v145))) <$> timRoom_roomName record
  , (\_v145 -> (7, ("desc",T.TString $ E.encodeUtf8 _v145))) <$> timRoom_desc record
  , (\_v145 -> (8, ("createTime",from_TimTime _v145))) <$> timRoom_createTime record
  , (\_v145 -> (9, ("extraList",T.TList (T.T_STRUCT typemap_TimNode) $ P.map (\_v151 -> from_TimNode _v151) $ Vector.toList _v145))) <$> timRoom_extraList record
  , (\_v145 -> (10, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k152,_v153) -> (T.TString $ E.encodeUtf8 _k152, T.TString $ E.encodeUtf8 _v153)) $ Map.toList _v145))) <$> timRoom_extraMap record
  ]
write_TimRoom :: (T.Protocol p, T.Transport t) => p t -> TimRoom -> P.IO ()
write_TimRoom oprot record = T.writeVal oprot $ from_TimRoom record
encode_TimRoom :: (T.Protocol p, T.Transport t) => p t -> TimRoom -> LBS.ByteString
encode_TimRoom oprot record = T.serializeVal oprot $ from_TimRoom record
to_TimRoom :: T.ThriftVal -> TimRoom
to_TimRoom (T.TStruct fields) = TimRoom{
  timRoom_tid = P.maybe (P.Nothing) (\(_,_val155) -> P.Just (case _val155 of {T.TStruct _val156 -> (to_Tid (T.TStruct _val156)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timRoom_founderTid = P.maybe (P.Nothing) (\(_,_val155) -> P.Just (case _val155 of {T.TStruct _val157 -> (to_Tid (T.TStruct _val157)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timRoom_HostsTid = P.maybe (P.Nothing) (\(_,_val155) -> P.Just (case _val155 of {T.TList _ _val158 -> (Vector.fromList $ P.map (\_v159 -> (case _v159 of {T.TStruct _val160 -> (to_Tid (T.TStruct _val160)); _ -> P.error "wrong type"})) _val158); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  timRoom_membersTid = P.maybe (P.Nothing) (\(_,_val155) -> P.Just (case _val155 of {T.TList _ _val161 -> (Vector.fromList $ P.map (\_v162 -> (case _v162 of {T.TStruct _val163 -> (to_Tid (T.TStruct _val163)); _ -> P.error "wrong type"})) _val161); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  timRoom_headurl = P.maybe (P.Nothing) (\(_,_val155) -> P.Just (case _val155 of {T.TString _val164 -> E.decodeUtf8 _val164; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  timRoom_roomName = P.maybe (P.Nothing) (\(_,_val155) -> P.Just (case _val155 of {T.TString _val165 -> E.decodeUtf8 _val165; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  timRoom_desc = P.maybe (P.Nothing) (\(_,_val155) -> P.Just (case _val155 of {T.TString _val166 -> E.decodeUtf8 _val166; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  timRoom_createTime = P.maybe (P.Nothing) (\(_,_val155) -> P.Just (case _val155 of {T.TStruct _val167 -> (to_TimTime (T.TStruct _val167)); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  timRoom_extraList = P.maybe (P.Nothing) (\(_,_val155) -> P.Just (case _val155 of {T.TList _ _val168 -> (Vector.fromList $ P.map (\_v169 -> (case _v169 of {T.TStruct _val170 -> (to_TimNode (T.TStruct _val170)); _ -> P.error "wrong type"})) _val168); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  timRoom_extraMap = P.maybe (P.Nothing) (\(_,_val155) -> P.Just (case _val155 of {T.TMap _ _ _val171 -> (Map.fromList $ P.map (\(_k173,_v172) -> ((case _k173 of {T.TString _val174 -> E.decodeUtf8 _val174; _ -> P.error "wrong type"}),(case _v172 of {T.TString _val175 -> E.decodeUtf8 _val175; _ -> P.error "wrong type"}))) _val171); _ -> P.error "wrong type"})) (Map.lookup (10) fields)
  }
to_TimRoom _ = P.error "not a struct"
read_TimRoom :: (T.Transport t, T.Protocol p) => p t -> P.IO TimRoom
read_TimRoom iprot = to_TimRoom <$> T.readVal iprot (T.T_STRUCT typemap_TimRoom)
decode_TimRoom :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimRoom
decode_TimRoom iprot bs = to_TimRoom $ T.deserializeVal iprot (T.T_STRUCT typemap_TimRoom) bs
typemap_TimRoom :: T.TypeMap
typemap_TimRoom = Map.fromList [(1,("tid",(T.T_STRUCT typemap_Tid))),(2,("founderTid",(T.T_STRUCT typemap_Tid))),(3,("HostsTid",(T.T_LIST (T.T_STRUCT typemap_Tid)))),(4,("membersTid",(T.T_LIST (T.T_STRUCT typemap_Tid)))),(5,("headurl",T.T_STRING)),(6,("roomName",T.T_STRING)),(7,("desc",T.T_STRING)),(8,("createTime",(T.T_STRUCT typemap_TimTime))),(9,("extraList",(T.T_LIST (T.T_STRUCT typemap_TimNode)))),(10,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TimRoom :: TimRoom
default_TimRoom = TimRoom{
  timRoom_tid = P.Nothing,
  timRoom_founderTid = P.Nothing,
  timRoom_HostsTid = P.Nothing,
  timRoom_membersTid = P.Nothing,
  timRoom_headurl = P.Nothing,
  timRoom_roomName = P.Nothing,
  timRoom_desc = P.Nothing,
  timRoom_createTime = P.Nothing,
  timRoom_extraList = P.Nothing,
  timRoom_extraMap = P.Nothing}
data TimPBean = TimPBean  { timPBean_threadId :: LT.Text
  , timPBean_fromTid :: P.Maybe Tid
  , timPBean_toTid :: P.Maybe Tid
  , timPBean_status :: P.Maybe LT.Text
  , timPBean_type :: P.Maybe LT.Text
  , timPBean_priority :: P.Maybe I.Int32
  , timPBean_show :: P.Maybe LT.Text
  , timPBean_leaguerTid :: P.Maybe Tid
  , timPBean_extraList :: P.Maybe (Vector.Vector TimNode)
  , timPBean_error :: P.Maybe TimError
  , timPBean_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimPBean where
  hashWithSalt salt record = salt   `H.hashWithSalt` timPBean_threadId record   `H.hashWithSalt` timPBean_fromTid record   `H.hashWithSalt` timPBean_toTid record   `H.hashWithSalt` timPBean_status record   `H.hashWithSalt` timPBean_type record   `H.hashWithSalt` timPBean_priority record   `H.hashWithSalt` timPBean_show record   `H.hashWithSalt` timPBean_leaguerTid record   `H.hashWithSalt` timPBean_extraList record   `H.hashWithSalt` timPBean_error record   `H.hashWithSalt` timPBean_extraMap record  
instance QC.Arbitrary TimPBean where 
  arbitrary = M.liftM TimPBean (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimPBean = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimPBean{timPBean_threadId = timPBean_threadId obj} then P.Nothing else P.Just $ default_TimPBean{timPBean_threadId = timPBean_threadId obj}
    , if obj == default_TimPBean{timPBean_fromTid = timPBean_fromTid obj} then P.Nothing else P.Just $ default_TimPBean{timPBean_fromTid = timPBean_fromTid obj}
    , if obj == default_TimPBean{timPBean_toTid = timPBean_toTid obj} then P.Nothing else P.Just $ default_TimPBean{timPBean_toTid = timPBean_toTid obj}
    , if obj == default_TimPBean{timPBean_status = timPBean_status obj} then P.Nothing else P.Just $ default_TimPBean{timPBean_status = timPBean_status obj}
    , if obj == default_TimPBean{timPBean_type = timPBean_type obj} then P.Nothing else P.Just $ default_TimPBean{timPBean_type = timPBean_type obj}
    , if obj == default_TimPBean{timPBean_priority = timPBean_priority obj} then P.Nothing else P.Just $ default_TimPBean{timPBean_priority = timPBean_priority obj}
    , if obj == default_TimPBean{timPBean_show = timPBean_show obj} then P.Nothing else P.Just $ default_TimPBean{timPBean_show = timPBean_show obj}
    , if obj == default_TimPBean{timPBean_leaguerTid = timPBean_leaguerTid obj} then P.Nothing else P.Just $ default_TimPBean{timPBean_leaguerTid = timPBean_leaguerTid obj}
    , if obj == default_TimPBean{timPBean_extraList = timPBean_extraList obj} then P.Nothing else P.Just $ default_TimPBean{timPBean_extraList = timPBean_extraList obj}
    , if obj == default_TimPBean{timPBean_error = timPBean_error obj} then P.Nothing else P.Just $ default_TimPBean{timPBean_error = timPBean_error obj}
    , if obj == default_TimPBean{timPBean_extraMap = timPBean_extraMap obj} then P.Nothing else P.Just $ default_TimPBean{timPBean_extraMap = timPBean_extraMap obj}
    ]
from_TimPBean :: TimPBean -> T.ThriftVal
from_TimPBean record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v178 -> P.Just (1, ("threadId",T.TString $ E.encodeUtf8 _v178))) $ timPBean_threadId record
  , (\_v178 -> (2, ("fromTid",from_Tid _v178))) <$> timPBean_fromTid record
  , (\_v178 -> (3, ("toTid",from_Tid _v178))) <$> timPBean_toTid record
  , (\_v178 -> (4, ("status",T.TString $ E.encodeUtf8 _v178))) <$> timPBean_status record
  , (\_v178 -> (5, ("type",T.TString $ E.encodeUtf8 _v178))) <$> timPBean_type record
  , (\_v178 -> (6, ("priority",T.TI32 _v178))) <$> timPBean_priority record
  , (\_v178 -> (7, ("show",T.TString $ E.encodeUtf8 _v178))) <$> timPBean_show record
  , (\_v178 -> (8, ("leaguerTid",from_Tid _v178))) <$> timPBean_leaguerTid record
  , (\_v178 -> (9, ("extraList",T.TList (T.T_STRUCT typemap_TimNode) $ P.map (\_v180 -> from_TimNode _v180) $ Vector.toList _v178))) <$> timPBean_extraList record
  , (\_v178 -> (10, ("error",from_TimError _v178))) <$> timPBean_error record
  , (\_v178 -> (11, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k181,_v182) -> (T.TString $ E.encodeUtf8 _k181, T.TString $ E.encodeUtf8 _v182)) $ Map.toList _v178))) <$> timPBean_extraMap record
  ]
write_TimPBean :: (T.Protocol p, T.Transport t) => p t -> TimPBean -> P.IO ()
write_TimPBean oprot record = T.writeVal oprot $ from_TimPBean record
encode_TimPBean :: (T.Protocol p, T.Transport t) => p t -> TimPBean -> LBS.ByteString
encode_TimPBean oprot record = T.serializeVal oprot $ from_TimPBean record
to_TimPBean :: T.ThriftVal -> TimPBean
to_TimPBean (T.TStruct fields) = TimPBean{
  timPBean_threadId = P.maybe (P.error "Missing required field: threadId") (\(_,_val184) -> (case _val184 of {T.TString _val185 -> E.decodeUtf8 _val185; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timPBean_fromTid = P.maybe (P.Nothing) (\(_,_val184) -> P.Just (case _val184 of {T.TStruct _val186 -> (to_Tid (T.TStruct _val186)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timPBean_toTid = P.maybe (P.Nothing) (\(_,_val184) -> P.Just (case _val184 of {T.TStruct _val187 -> (to_Tid (T.TStruct _val187)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  timPBean_status = P.maybe (P.Nothing) (\(_,_val184) -> P.Just (case _val184 of {T.TString _val188 -> E.decodeUtf8 _val188; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  timPBean_type = P.maybe (P.Nothing) (\(_,_val184) -> P.Just (case _val184 of {T.TString _val189 -> E.decodeUtf8 _val189; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  timPBean_priority = P.maybe (P.Nothing) (\(_,_val184) -> P.Just (case _val184 of {T.TI32 _val190 -> _val190; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  timPBean_show = P.maybe (P.Nothing) (\(_,_val184) -> P.Just (case _val184 of {T.TString _val191 -> E.decodeUtf8 _val191; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  timPBean_leaguerTid = P.maybe (P.Nothing) (\(_,_val184) -> P.Just (case _val184 of {T.TStruct _val192 -> (to_Tid (T.TStruct _val192)); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  timPBean_extraList = P.maybe (P.Nothing) (\(_,_val184) -> P.Just (case _val184 of {T.TList _ _val193 -> (Vector.fromList $ P.map (\_v194 -> (case _v194 of {T.TStruct _val195 -> (to_TimNode (T.TStruct _val195)); _ -> P.error "wrong type"})) _val193); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  timPBean_error = P.maybe (P.Nothing) (\(_,_val184) -> P.Just (case _val184 of {T.TStruct _val196 -> (to_TimError (T.TStruct _val196)); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  timPBean_extraMap = P.maybe (P.Nothing) (\(_,_val184) -> P.Just (case _val184 of {T.TMap _ _ _val197 -> (Map.fromList $ P.map (\(_k199,_v198) -> ((case _k199 of {T.TString _val200 -> E.decodeUtf8 _val200; _ -> P.error "wrong type"}),(case _v198 of {T.TString _val201 -> E.decodeUtf8 _val201; _ -> P.error "wrong type"}))) _val197); _ -> P.error "wrong type"})) (Map.lookup (11) fields)
  }
to_TimPBean _ = P.error "not a struct"
read_TimPBean :: (T.Transport t, T.Protocol p) => p t -> P.IO TimPBean
read_TimPBean iprot = to_TimPBean <$> T.readVal iprot (T.T_STRUCT typemap_TimPBean)
decode_TimPBean :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimPBean
decode_TimPBean iprot bs = to_TimPBean $ T.deserializeVal iprot (T.T_STRUCT typemap_TimPBean) bs
typemap_TimPBean :: T.TypeMap
typemap_TimPBean = Map.fromList [(1,("threadId",T.T_STRING)),(2,("fromTid",(T.T_STRUCT typemap_Tid))),(3,("toTid",(T.T_STRUCT typemap_Tid))),(4,("status",T.T_STRING)),(5,("type",T.T_STRING)),(6,("priority",T.T_I32)),(7,("show",T.T_STRING)),(8,("leaguerTid",(T.T_STRUCT typemap_Tid))),(9,("extraList",(T.T_LIST (T.T_STRUCT typemap_TimNode)))),(10,("error",(T.T_STRUCT typemap_TimError))),(11,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TimPBean :: TimPBean
default_TimPBean = TimPBean{
  timPBean_threadId = "",
  timPBean_fromTid = P.Nothing,
  timPBean_toTid = P.Nothing,
  timPBean_status = P.Nothing,
  timPBean_type = P.Nothing,
  timPBean_priority = P.Nothing,
  timPBean_show = P.Nothing,
  timPBean_leaguerTid = P.Nothing,
  timPBean_extraList = P.Nothing,
  timPBean_error = P.Nothing,
  timPBean_extraMap = P.Nothing}
data TimMBean = TimMBean  { timMBean_threadId :: LT.Text
  , timMBean_mid :: P.Maybe LT.Text
  , timMBean_fromTid :: P.Maybe Tid
  , timMBean_toTid :: P.Maybe Tid
  , timMBean_body :: P.Maybe LT.Text
  , timMBean_type :: P.Maybe LT.Text
  , timMBean_msgType :: P.Maybe I.Int16
  , timMBean_offline :: P.Maybe TimTime
  , timMBean_leaguerTid :: P.Maybe Tid
  , timMBean_extraList :: P.Maybe (Vector.Vector TimNode)
  , timMBean_timestamp :: P.Maybe LT.Text
  , timMBean_error :: P.Maybe TimError
  , timMBean_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  , timMBean_readstatus :: P.Maybe I.Int16
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimMBean where
  hashWithSalt salt record = salt   `H.hashWithSalt` timMBean_threadId record   `H.hashWithSalt` timMBean_mid record   `H.hashWithSalt` timMBean_fromTid record   `H.hashWithSalt` timMBean_toTid record   `H.hashWithSalt` timMBean_body record   `H.hashWithSalt` timMBean_type record   `H.hashWithSalt` timMBean_msgType record   `H.hashWithSalt` timMBean_offline record   `H.hashWithSalt` timMBean_leaguerTid record   `H.hashWithSalt` timMBean_extraList record   `H.hashWithSalt` timMBean_timestamp record   `H.hashWithSalt` timMBean_error record   `H.hashWithSalt` timMBean_extraMap record   `H.hashWithSalt` timMBean_readstatus record  
instance QC.Arbitrary TimMBean where 
  arbitrary = M.liftM TimMBean (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimMBean = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimMBean{timMBean_threadId = timMBean_threadId obj} then P.Nothing else P.Just $ default_TimMBean{timMBean_threadId = timMBean_threadId obj}
    , if obj == default_TimMBean{timMBean_mid = timMBean_mid obj} then P.Nothing else P.Just $ default_TimMBean{timMBean_mid = timMBean_mid obj}
    , if obj == default_TimMBean{timMBean_fromTid = timMBean_fromTid obj} then P.Nothing else P.Just $ default_TimMBean{timMBean_fromTid = timMBean_fromTid obj}
    , if obj == default_TimMBean{timMBean_toTid = timMBean_toTid obj} then P.Nothing else P.Just $ default_TimMBean{timMBean_toTid = timMBean_toTid obj}
    , if obj == default_TimMBean{timMBean_body = timMBean_body obj} then P.Nothing else P.Just $ default_TimMBean{timMBean_body = timMBean_body obj}
    , if obj == default_TimMBean{timMBean_type = timMBean_type obj} then P.Nothing else P.Just $ default_TimMBean{timMBean_type = timMBean_type obj}
    , if obj == default_TimMBean{timMBean_msgType = timMBean_msgType obj} then P.Nothing else P.Just $ default_TimMBean{timMBean_msgType = timMBean_msgType obj}
    , if obj == default_TimMBean{timMBean_offline = timMBean_offline obj} then P.Nothing else P.Just $ default_TimMBean{timMBean_offline = timMBean_offline obj}
    , if obj == default_TimMBean{timMBean_leaguerTid = timMBean_leaguerTid obj} then P.Nothing else P.Just $ default_TimMBean{timMBean_leaguerTid = timMBean_leaguerTid obj}
    , if obj == default_TimMBean{timMBean_extraList = timMBean_extraList obj} then P.Nothing else P.Just $ default_TimMBean{timMBean_extraList = timMBean_extraList obj}
    , if obj == default_TimMBean{timMBean_timestamp = timMBean_timestamp obj} then P.Nothing else P.Just $ default_TimMBean{timMBean_timestamp = timMBean_timestamp obj}
    , if obj == default_TimMBean{timMBean_error = timMBean_error obj} then P.Nothing else P.Just $ default_TimMBean{timMBean_error = timMBean_error obj}
    , if obj == default_TimMBean{timMBean_extraMap = timMBean_extraMap obj} then P.Nothing else P.Just $ default_TimMBean{timMBean_extraMap = timMBean_extraMap obj}
    , if obj == default_TimMBean{timMBean_readstatus = timMBean_readstatus obj} then P.Nothing else P.Just $ default_TimMBean{timMBean_readstatus = timMBean_readstatus obj}
    ]
from_TimMBean :: TimMBean -> T.ThriftVal
from_TimMBean record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v204 -> P.Just (1, ("threadId",T.TString $ E.encodeUtf8 _v204))) $ timMBean_threadId record
  , (\_v204 -> (2, ("mid",T.TString $ E.encodeUtf8 _v204))) <$> timMBean_mid record
  , (\_v204 -> (3, ("fromTid",from_Tid _v204))) <$> timMBean_fromTid record
  , (\_v204 -> (4, ("toTid",from_Tid _v204))) <$> timMBean_toTid record
  , (\_v204 -> (5, ("body",T.TString $ E.encodeUtf8 _v204))) <$> timMBean_body record
  , (\_v204 -> (6, ("type",T.TString $ E.encodeUtf8 _v204))) <$> timMBean_type record
  , (\_v204 -> (7, ("msgType",T.TI16 _v204))) <$> timMBean_msgType record
  , (\_v204 -> (8, ("offline",from_TimTime _v204))) <$> timMBean_offline record
  , (\_v204 -> (9, ("leaguerTid",from_Tid _v204))) <$> timMBean_leaguerTid record
  , (\_v204 -> (10, ("extraList",T.TList (T.T_STRUCT typemap_TimNode) $ P.map (\_v206 -> from_TimNode _v206) $ Vector.toList _v204))) <$> timMBean_extraList record
  , (\_v204 -> (11, ("timestamp",T.TString $ E.encodeUtf8 _v204))) <$> timMBean_timestamp record
  , (\_v204 -> (12, ("error",from_TimError _v204))) <$> timMBean_error record
  , (\_v204 -> (13, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k207,_v208) -> (T.TString $ E.encodeUtf8 _k207, T.TString $ E.encodeUtf8 _v208)) $ Map.toList _v204))) <$> timMBean_extraMap record
  , (\_v204 -> (14, ("readstatus",T.TI16 _v204))) <$> timMBean_readstatus record
  ]
write_TimMBean :: (T.Protocol p, T.Transport t) => p t -> TimMBean -> P.IO ()
write_TimMBean oprot record = T.writeVal oprot $ from_TimMBean record
encode_TimMBean :: (T.Protocol p, T.Transport t) => p t -> TimMBean -> LBS.ByteString
encode_TimMBean oprot record = T.serializeVal oprot $ from_TimMBean record
to_TimMBean :: T.ThriftVal -> TimMBean
to_TimMBean (T.TStruct fields) = TimMBean{
  timMBean_threadId = P.maybe (P.error "Missing required field: threadId") (\(_,_val210) -> (case _val210 of {T.TString _val211 -> E.decodeUtf8 _val211; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timMBean_mid = P.maybe (P.Nothing) (\(_,_val210) -> P.Just (case _val210 of {T.TString _val212 -> E.decodeUtf8 _val212; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timMBean_fromTid = P.maybe (P.Nothing) (\(_,_val210) -> P.Just (case _val210 of {T.TStruct _val213 -> (to_Tid (T.TStruct _val213)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  timMBean_toTid = P.maybe (P.Nothing) (\(_,_val210) -> P.Just (case _val210 of {T.TStruct _val214 -> (to_Tid (T.TStruct _val214)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  timMBean_body = P.maybe (P.Nothing) (\(_,_val210) -> P.Just (case _val210 of {T.TString _val215 -> E.decodeUtf8 _val215; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  timMBean_type = P.maybe (P.Nothing) (\(_,_val210) -> P.Just (case _val210 of {T.TString _val216 -> E.decodeUtf8 _val216; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  timMBean_msgType = P.maybe (P.Nothing) (\(_,_val210) -> P.Just (case _val210 of {T.TI16 _val217 -> _val217; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  timMBean_offline = P.maybe (P.Nothing) (\(_,_val210) -> P.Just (case _val210 of {T.TStruct _val218 -> (to_TimTime (T.TStruct _val218)); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  timMBean_leaguerTid = P.maybe (P.Nothing) (\(_,_val210) -> P.Just (case _val210 of {T.TStruct _val219 -> (to_Tid (T.TStruct _val219)); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  timMBean_extraList = P.maybe (P.Nothing) (\(_,_val210) -> P.Just (case _val210 of {T.TList _ _val220 -> (Vector.fromList $ P.map (\_v221 -> (case _v221 of {T.TStruct _val222 -> (to_TimNode (T.TStruct _val222)); _ -> P.error "wrong type"})) _val220); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  timMBean_timestamp = P.maybe (P.Nothing) (\(_,_val210) -> P.Just (case _val210 of {T.TString _val223 -> E.decodeUtf8 _val223; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  timMBean_error = P.maybe (P.Nothing) (\(_,_val210) -> P.Just (case _val210 of {T.TStruct _val224 -> (to_TimError (T.TStruct _val224)); _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  timMBean_extraMap = P.maybe (P.Nothing) (\(_,_val210) -> P.Just (case _val210 of {T.TMap _ _ _val225 -> (Map.fromList $ P.map (\(_k227,_v226) -> ((case _k227 of {T.TString _val228 -> E.decodeUtf8 _val228; _ -> P.error "wrong type"}),(case _v226 of {T.TString _val229 -> E.decodeUtf8 _val229; _ -> P.error "wrong type"}))) _val225); _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  timMBean_readstatus = P.maybe (P.Nothing) (\(_,_val210) -> P.Just (case _val210 of {T.TI16 _val230 -> _val230; _ -> P.error "wrong type"})) (Map.lookup (14) fields)
  }
to_TimMBean _ = P.error "not a struct"
read_TimMBean :: (T.Transport t, T.Protocol p) => p t -> P.IO TimMBean
read_TimMBean iprot = to_TimMBean <$> T.readVal iprot (T.T_STRUCT typemap_TimMBean)
decode_TimMBean :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimMBean
decode_TimMBean iprot bs = to_TimMBean $ T.deserializeVal iprot (T.T_STRUCT typemap_TimMBean) bs
typemap_TimMBean :: T.TypeMap
typemap_TimMBean = Map.fromList [(1,("threadId",T.T_STRING)),(2,("mid",T.T_STRING)),(3,("fromTid",(T.T_STRUCT typemap_Tid))),(4,("toTid",(T.T_STRUCT typemap_Tid))),(5,("body",T.T_STRING)),(6,("type",T.T_STRING)),(7,("msgType",T.T_I16)),(8,("offline",(T.T_STRUCT typemap_TimTime))),(9,("leaguerTid",(T.T_STRUCT typemap_Tid))),(10,("extraList",(T.T_LIST (T.T_STRUCT typemap_TimNode)))),(11,("timestamp",T.T_STRING)),(12,("error",(T.T_STRUCT typemap_TimError))),(13,("extraMap",(T.T_MAP T.T_STRING T.T_STRING))),(14,("readstatus",T.T_I16))]
default_TimMBean :: TimMBean
default_TimMBean = TimMBean{
  timMBean_threadId = "",
  timMBean_mid = P.Nothing,
  timMBean_fromTid = P.Nothing,
  timMBean_toTid = P.Nothing,
  timMBean_body = P.Nothing,
  timMBean_type = P.Nothing,
  timMBean_msgType = P.Nothing,
  timMBean_offline = P.Nothing,
  timMBean_leaguerTid = P.Nothing,
  timMBean_extraList = P.Nothing,
  timMBean_timestamp = P.Nothing,
  timMBean_error = P.Nothing,
  timMBean_extraMap = P.Nothing,
  timMBean_readstatus = P.Nothing}
data TimIqBean = TimIqBean  { timIqBean_threadId :: LT.Text
  , timIqBean_fromTid :: P.Maybe Tid
  , timIqBean_toTid :: P.Maybe Tid
  , timIqBean_type :: P.Maybe LT.Text
  , timIqBean_extraList :: P.Maybe (Vector.Vector TimNode)
  , timIqBean_error :: P.Maybe TimError
  , timIqBean_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimIqBean where
  hashWithSalt salt record = salt   `H.hashWithSalt` timIqBean_threadId record   `H.hashWithSalt` timIqBean_fromTid record   `H.hashWithSalt` timIqBean_toTid record   `H.hashWithSalt` timIqBean_type record   `H.hashWithSalt` timIqBean_extraList record   `H.hashWithSalt` timIqBean_error record   `H.hashWithSalt` timIqBean_extraMap record  
instance QC.Arbitrary TimIqBean where 
  arbitrary = M.liftM TimIqBean (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimIqBean = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimIqBean{timIqBean_threadId = timIqBean_threadId obj} then P.Nothing else P.Just $ default_TimIqBean{timIqBean_threadId = timIqBean_threadId obj}
    , if obj == default_TimIqBean{timIqBean_fromTid = timIqBean_fromTid obj} then P.Nothing else P.Just $ default_TimIqBean{timIqBean_fromTid = timIqBean_fromTid obj}
    , if obj == default_TimIqBean{timIqBean_toTid = timIqBean_toTid obj} then P.Nothing else P.Just $ default_TimIqBean{timIqBean_toTid = timIqBean_toTid obj}
    , if obj == default_TimIqBean{timIqBean_type = timIqBean_type obj} then P.Nothing else P.Just $ default_TimIqBean{timIqBean_type = timIqBean_type obj}
    , if obj == default_TimIqBean{timIqBean_extraList = timIqBean_extraList obj} then P.Nothing else P.Just $ default_TimIqBean{timIqBean_extraList = timIqBean_extraList obj}
    , if obj == default_TimIqBean{timIqBean_error = timIqBean_error obj} then P.Nothing else P.Just $ default_TimIqBean{timIqBean_error = timIqBean_error obj}
    , if obj == default_TimIqBean{timIqBean_extraMap = timIqBean_extraMap obj} then P.Nothing else P.Just $ default_TimIqBean{timIqBean_extraMap = timIqBean_extraMap obj}
    ]
from_TimIqBean :: TimIqBean -> T.ThriftVal
from_TimIqBean record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v233 -> P.Just (1, ("threadId",T.TString $ E.encodeUtf8 _v233))) $ timIqBean_threadId record
  , (\_v233 -> (2, ("fromTid",from_Tid _v233))) <$> timIqBean_fromTid record
  , (\_v233 -> (3, ("toTid",from_Tid _v233))) <$> timIqBean_toTid record
  , (\_v233 -> (4, ("type",T.TString $ E.encodeUtf8 _v233))) <$> timIqBean_type record
  , (\_v233 -> (5, ("extraList",T.TList (T.T_STRUCT typemap_TimNode) $ P.map (\_v235 -> from_TimNode _v235) $ Vector.toList _v233))) <$> timIqBean_extraList record
  , (\_v233 -> (6, ("error",from_TimError _v233))) <$> timIqBean_error record
  , (\_v233 -> (7, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k236,_v237) -> (T.TString $ E.encodeUtf8 _k236, T.TString $ E.encodeUtf8 _v237)) $ Map.toList _v233))) <$> timIqBean_extraMap record
  ]
write_TimIqBean :: (T.Protocol p, T.Transport t) => p t -> TimIqBean -> P.IO ()
write_TimIqBean oprot record = T.writeVal oprot $ from_TimIqBean record
encode_TimIqBean :: (T.Protocol p, T.Transport t) => p t -> TimIqBean -> LBS.ByteString
encode_TimIqBean oprot record = T.serializeVal oprot $ from_TimIqBean record
to_TimIqBean :: T.ThriftVal -> TimIqBean
to_TimIqBean (T.TStruct fields) = TimIqBean{
  timIqBean_threadId = P.maybe (P.error "Missing required field: threadId") (\(_,_val239) -> (case _val239 of {T.TString _val240 -> E.decodeUtf8 _val240; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timIqBean_fromTid = P.maybe (P.Nothing) (\(_,_val239) -> P.Just (case _val239 of {T.TStruct _val241 -> (to_Tid (T.TStruct _val241)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timIqBean_toTid = P.maybe (P.Nothing) (\(_,_val239) -> P.Just (case _val239 of {T.TStruct _val242 -> (to_Tid (T.TStruct _val242)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  timIqBean_type = P.maybe (P.Nothing) (\(_,_val239) -> P.Just (case _val239 of {T.TString _val243 -> E.decodeUtf8 _val243; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  timIqBean_extraList = P.maybe (P.Nothing) (\(_,_val239) -> P.Just (case _val239 of {T.TList _ _val244 -> (Vector.fromList $ P.map (\_v245 -> (case _v245 of {T.TStruct _val246 -> (to_TimNode (T.TStruct _val246)); _ -> P.error "wrong type"})) _val244); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  timIqBean_error = P.maybe (P.Nothing) (\(_,_val239) -> P.Just (case _val239 of {T.TStruct _val247 -> (to_TimError (T.TStruct _val247)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  timIqBean_extraMap = P.maybe (P.Nothing) (\(_,_val239) -> P.Just (case _val239 of {T.TMap _ _ _val248 -> (Map.fromList $ P.map (\(_k250,_v249) -> ((case _k250 of {T.TString _val251 -> E.decodeUtf8 _val251; _ -> P.error "wrong type"}),(case _v249 of {T.TString _val252 -> E.decodeUtf8 _val252; _ -> P.error "wrong type"}))) _val248); _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_TimIqBean _ = P.error "not a struct"
read_TimIqBean :: (T.Transport t, T.Protocol p) => p t -> P.IO TimIqBean
read_TimIqBean iprot = to_TimIqBean <$> T.readVal iprot (T.T_STRUCT typemap_TimIqBean)
decode_TimIqBean :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimIqBean
decode_TimIqBean iprot bs = to_TimIqBean $ T.deserializeVal iprot (T.T_STRUCT typemap_TimIqBean) bs
typemap_TimIqBean :: T.TypeMap
typemap_TimIqBean = Map.fromList [(1,("threadId",T.T_STRING)),(2,("fromTid",(T.T_STRUCT typemap_Tid))),(3,("toTid",(T.T_STRUCT typemap_Tid))),(4,("type",T.T_STRING)),(5,("extraList",(T.T_LIST (T.T_STRUCT typemap_TimNode)))),(6,("error",(T.T_STRUCT typemap_TimError))),(7,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TimIqBean :: TimIqBean
default_TimIqBean = TimIqBean{
  timIqBean_threadId = "",
  timIqBean_fromTid = P.Nothing,
  timIqBean_toTid = P.Nothing,
  timIqBean_type = P.Nothing,
  timIqBean_extraList = P.Nothing,
  timIqBean_error = P.Nothing,
  timIqBean_extraMap = P.Nothing}
data TimRoster = TimRoster  { timRoster_subscription :: LT.Text
  , timRoster_tid :: Tid
  , timRoster_name :: P.Maybe LT.Text
  , timRoster_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimRoster where
  hashWithSalt salt record = salt   `H.hashWithSalt` timRoster_subscription record   `H.hashWithSalt` timRoster_tid record   `H.hashWithSalt` timRoster_name record   `H.hashWithSalt` timRoster_extraMap record  
instance QC.Arbitrary TimRoster where 
  arbitrary = M.liftM TimRoster (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimRoster = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimRoster{timRoster_subscription = timRoster_subscription obj} then P.Nothing else P.Just $ default_TimRoster{timRoster_subscription = timRoster_subscription obj}
    , if obj == default_TimRoster{timRoster_tid = timRoster_tid obj} then P.Nothing else P.Just $ default_TimRoster{timRoster_tid = timRoster_tid obj}
    , if obj == default_TimRoster{timRoster_name = timRoster_name obj} then P.Nothing else P.Just $ default_TimRoster{timRoster_name = timRoster_name obj}
    , if obj == default_TimRoster{timRoster_extraMap = timRoster_extraMap obj} then P.Nothing else P.Just $ default_TimRoster{timRoster_extraMap = timRoster_extraMap obj}
    ]
from_TimRoster :: TimRoster -> T.ThriftVal
from_TimRoster record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v255 -> P.Just (1, ("subscription",T.TString $ E.encodeUtf8 _v255))) $ timRoster_subscription record
  , (\_v255 -> P.Just (2, ("tid",from_Tid _v255))) $ timRoster_tid record
  , (\_v255 -> (3, ("name",T.TString $ E.encodeUtf8 _v255))) <$> timRoster_name record
  , (\_v255 -> (4, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k256,_v257) -> (T.TString $ E.encodeUtf8 _k256, T.TString $ E.encodeUtf8 _v257)) $ Map.toList _v255))) <$> timRoster_extraMap record
  ]
write_TimRoster :: (T.Protocol p, T.Transport t) => p t -> TimRoster -> P.IO ()
write_TimRoster oprot record = T.writeVal oprot $ from_TimRoster record
encode_TimRoster :: (T.Protocol p, T.Transport t) => p t -> TimRoster -> LBS.ByteString
encode_TimRoster oprot record = T.serializeVal oprot $ from_TimRoster record
to_TimRoster :: T.ThriftVal -> TimRoster
to_TimRoster (T.TStruct fields) = TimRoster{
  timRoster_subscription = P.maybe (P.error "Missing required field: subscription") (\(_,_val259) -> (case _val259 of {T.TString _val260 -> E.decodeUtf8 _val260; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timRoster_tid = P.maybe (P.error "Missing required field: tid") (\(_,_val259) -> (case _val259 of {T.TStruct _val261 -> (to_Tid (T.TStruct _val261)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timRoster_name = P.maybe (P.Nothing) (\(_,_val259) -> P.Just (case _val259 of {T.TString _val262 -> E.decodeUtf8 _val262; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  timRoster_extraMap = P.maybe (P.Nothing) (\(_,_val259) -> P.Just (case _val259 of {T.TMap _ _ _val263 -> (Map.fromList $ P.map (\(_k265,_v264) -> ((case _k265 of {T.TString _val266 -> E.decodeUtf8 _val266; _ -> P.error "wrong type"}),(case _v264 of {T.TString _val267 -> E.decodeUtf8 _val267; _ -> P.error "wrong type"}))) _val263); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_TimRoster _ = P.error "not a struct"
read_TimRoster :: (T.Transport t, T.Protocol p) => p t -> P.IO TimRoster
read_TimRoster iprot = to_TimRoster <$> T.readVal iprot (T.T_STRUCT typemap_TimRoster)
decode_TimRoster :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimRoster
decode_TimRoster iprot bs = to_TimRoster $ T.deserializeVal iprot (T.T_STRUCT typemap_TimRoster) bs
typemap_TimRoster :: T.TypeMap
typemap_TimRoster = Map.fromList [(1,("subscription",T.T_STRING)),(2,("tid",(T.T_STRUCT typemap_Tid))),(3,("name",T.T_STRING)),(4,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TimRoster :: TimRoster
default_TimRoster = TimRoster{
  timRoster_subscription = "",
  timRoster_tid = default_Tid,
  timRoster_name = P.Nothing,
  timRoster_extraMap = P.Nothing}
data TimRemoteUserBean = TimRemoteUserBean  { timRemoteUserBean_error :: P.Maybe TimError
  , timRemoteUserBean_ub :: P.Maybe TimUserBean
  , timRemoteUserBean_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimRemoteUserBean where
  hashWithSalt salt record = salt   `H.hashWithSalt` timRemoteUserBean_error record   `H.hashWithSalt` timRemoteUserBean_ub record   `H.hashWithSalt` timRemoteUserBean_extraMap record  
instance QC.Arbitrary TimRemoteUserBean where 
  arbitrary = M.liftM TimRemoteUserBean (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimRemoteUserBean = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimRemoteUserBean{timRemoteUserBean_error = timRemoteUserBean_error obj} then P.Nothing else P.Just $ default_TimRemoteUserBean{timRemoteUserBean_error = timRemoteUserBean_error obj}
    , if obj == default_TimRemoteUserBean{timRemoteUserBean_ub = timRemoteUserBean_ub obj} then P.Nothing else P.Just $ default_TimRemoteUserBean{timRemoteUserBean_ub = timRemoteUserBean_ub obj}
    , if obj == default_TimRemoteUserBean{timRemoteUserBean_extraMap = timRemoteUserBean_extraMap obj} then P.Nothing else P.Just $ default_TimRemoteUserBean{timRemoteUserBean_extraMap = timRemoteUserBean_extraMap obj}
    ]
from_TimRemoteUserBean :: TimRemoteUserBean -> T.ThriftVal
from_TimRemoteUserBean record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v270 -> (1, ("error",from_TimError _v270))) <$> timRemoteUserBean_error record
  , (\_v270 -> (2, ("ub",from_TimUserBean _v270))) <$> timRemoteUserBean_ub record
  , (\_v270 -> (3, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k271,_v272) -> (T.TString $ E.encodeUtf8 _k271, T.TString $ E.encodeUtf8 _v272)) $ Map.toList _v270))) <$> timRemoteUserBean_extraMap record
  ]
write_TimRemoteUserBean :: (T.Protocol p, T.Transport t) => p t -> TimRemoteUserBean -> P.IO ()
write_TimRemoteUserBean oprot record = T.writeVal oprot $ from_TimRemoteUserBean record
encode_TimRemoteUserBean :: (T.Protocol p, T.Transport t) => p t -> TimRemoteUserBean -> LBS.ByteString
encode_TimRemoteUserBean oprot record = T.serializeVal oprot $ from_TimRemoteUserBean record
to_TimRemoteUserBean :: T.ThriftVal -> TimRemoteUserBean
to_TimRemoteUserBean (T.TStruct fields) = TimRemoteUserBean{
  timRemoteUserBean_error = P.maybe (P.Nothing) (\(_,_val274) -> P.Just (case _val274 of {T.TStruct _val275 -> (to_TimError (T.TStruct _val275)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timRemoteUserBean_ub = P.maybe (P.Nothing) (\(_,_val274) -> P.Just (case _val274 of {T.TStruct _val276 -> (to_TimUserBean (T.TStruct _val276)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timRemoteUserBean_extraMap = P.maybe (P.Nothing) (\(_,_val274) -> P.Just (case _val274 of {T.TMap _ _ _val277 -> (Map.fromList $ P.map (\(_k279,_v278) -> ((case _k279 of {T.TString _val280 -> E.decodeUtf8 _val280; _ -> P.error "wrong type"}),(case _v278 of {T.TString _val281 -> E.decodeUtf8 _val281; _ -> P.error "wrong type"}))) _val277); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_TimRemoteUserBean _ = P.error "not a struct"
read_TimRemoteUserBean :: (T.Transport t, T.Protocol p) => p t -> P.IO TimRemoteUserBean
read_TimRemoteUserBean iprot = to_TimRemoteUserBean <$> T.readVal iprot (T.T_STRUCT typemap_TimRemoteUserBean)
decode_TimRemoteUserBean :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimRemoteUserBean
decode_TimRemoteUserBean iprot bs = to_TimRemoteUserBean $ T.deserializeVal iprot (T.T_STRUCT typemap_TimRemoteUserBean) bs
typemap_TimRemoteUserBean :: T.TypeMap
typemap_TimRemoteUserBean = Map.fromList [(1,("error",(T.T_STRUCT typemap_TimError))),(2,("ub",(T.T_STRUCT typemap_TimUserBean))),(3,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TimRemoteUserBean :: TimRemoteUserBean
default_TimRemoteUserBean = TimRemoteUserBean{
  timRemoteUserBean_error = P.Nothing,
  timRemoteUserBean_ub = P.Nothing,
  timRemoteUserBean_extraMap = P.Nothing}
data TimRemoteRoom = TimRemoteRoom  { timRemoteRoom_error :: P.Maybe TimError
  , timRemoteRoom_room :: P.Maybe TimRoom
  , timRemoteRoom_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimRemoteRoom where
  hashWithSalt salt record = salt   `H.hashWithSalt` timRemoteRoom_error record   `H.hashWithSalt` timRemoteRoom_room record   `H.hashWithSalt` timRemoteRoom_extraMap record  
instance QC.Arbitrary TimRemoteRoom where 
  arbitrary = M.liftM TimRemoteRoom (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimRemoteRoom = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimRemoteRoom{timRemoteRoom_error = timRemoteRoom_error obj} then P.Nothing else P.Just $ default_TimRemoteRoom{timRemoteRoom_error = timRemoteRoom_error obj}
    , if obj == default_TimRemoteRoom{timRemoteRoom_room = timRemoteRoom_room obj} then P.Nothing else P.Just $ default_TimRemoteRoom{timRemoteRoom_room = timRemoteRoom_room obj}
    , if obj == default_TimRemoteRoom{timRemoteRoom_extraMap = timRemoteRoom_extraMap obj} then P.Nothing else P.Just $ default_TimRemoteRoom{timRemoteRoom_extraMap = timRemoteRoom_extraMap obj}
    ]
from_TimRemoteRoom :: TimRemoteRoom -> T.ThriftVal
from_TimRemoteRoom record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v284 -> (1, ("error",from_TimError _v284))) <$> timRemoteRoom_error record
  , (\_v284 -> (2, ("room",from_TimRoom _v284))) <$> timRemoteRoom_room record
  , (\_v284 -> (3, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k285,_v286) -> (T.TString $ E.encodeUtf8 _k285, T.TString $ E.encodeUtf8 _v286)) $ Map.toList _v284))) <$> timRemoteRoom_extraMap record
  ]
write_TimRemoteRoom :: (T.Protocol p, T.Transport t) => p t -> TimRemoteRoom -> P.IO ()
write_TimRemoteRoom oprot record = T.writeVal oprot $ from_TimRemoteRoom record
encode_TimRemoteRoom :: (T.Protocol p, T.Transport t) => p t -> TimRemoteRoom -> LBS.ByteString
encode_TimRemoteRoom oprot record = T.serializeVal oprot $ from_TimRemoteRoom record
to_TimRemoteRoom :: T.ThriftVal -> TimRemoteRoom
to_TimRemoteRoom (T.TStruct fields) = TimRemoteRoom{
  timRemoteRoom_error = P.maybe (P.Nothing) (\(_,_val288) -> P.Just (case _val288 of {T.TStruct _val289 -> (to_TimError (T.TStruct _val289)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timRemoteRoom_room = P.maybe (P.Nothing) (\(_,_val288) -> P.Just (case _val288 of {T.TStruct _val290 -> (to_TimRoom (T.TStruct _val290)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timRemoteRoom_extraMap = P.maybe (P.Nothing) (\(_,_val288) -> P.Just (case _val288 of {T.TMap _ _ _val291 -> (Map.fromList $ P.map (\(_k293,_v292) -> ((case _k293 of {T.TString _val294 -> E.decodeUtf8 _val294; _ -> P.error "wrong type"}),(case _v292 of {T.TString _val295 -> E.decodeUtf8 _val295; _ -> P.error "wrong type"}))) _val291); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_TimRemoteRoom _ = P.error "not a struct"
read_TimRemoteRoom :: (T.Transport t, T.Protocol p) => p t -> P.IO TimRemoteRoom
read_TimRemoteRoom iprot = to_TimRemoteRoom <$> T.readVal iprot (T.T_STRUCT typemap_TimRemoteRoom)
decode_TimRemoteRoom :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimRemoteRoom
decode_TimRemoteRoom iprot bs = to_TimRemoteRoom $ T.deserializeVal iprot (T.T_STRUCT typemap_TimRemoteRoom) bs
typemap_TimRemoteRoom :: T.TypeMap
typemap_TimRemoteRoom = Map.fromList [(1,("error",(T.T_STRUCT typemap_TimError))),(2,("room",(T.T_STRUCT typemap_TimRoom))),(3,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TimRemoteRoom :: TimRemoteRoom
default_TimRemoteRoom = TimRemoteRoom{
  timRemoteRoom_error = P.Nothing,
  timRemoteRoom_room = P.Nothing,
  timRemoteRoom_extraMap = P.Nothing}
data TimResponseBean = TimResponseBean  { timResponseBean_threadId :: P.Maybe LT.Text
  , timResponseBean_error :: P.Maybe TimError
  , timResponseBean_extraList :: P.Maybe (Vector.Vector TimNode)
  , timResponseBean_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimResponseBean where
  hashWithSalt salt record = salt   `H.hashWithSalt` timResponseBean_threadId record   `H.hashWithSalt` timResponseBean_error record   `H.hashWithSalt` timResponseBean_extraList record   `H.hashWithSalt` timResponseBean_extraMap record  
instance QC.Arbitrary TimResponseBean where 
  arbitrary = M.liftM TimResponseBean (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimResponseBean = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimResponseBean{timResponseBean_threadId = timResponseBean_threadId obj} then P.Nothing else P.Just $ default_TimResponseBean{timResponseBean_threadId = timResponseBean_threadId obj}
    , if obj == default_TimResponseBean{timResponseBean_error = timResponseBean_error obj} then P.Nothing else P.Just $ default_TimResponseBean{timResponseBean_error = timResponseBean_error obj}
    , if obj == default_TimResponseBean{timResponseBean_extraList = timResponseBean_extraList obj} then P.Nothing else P.Just $ default_TimResponseBean{timResponseBean_extraList = timResponseBean_extraList obj}
    , if obj == default_TimResponseBean{timResponseBean_extraMap = timResponseBean_extraMap obj} then P.Nothing else P.Just $ default_TimResponseBean{timResponseBean_extraMap = timResponseBean_extraMap obj}
    ]
from_TimResponseBean :: TimResponseBean -> T.ThriftVal
from_TimResponseBean record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v298 -> (1, ("threadId",T.TString $ E.encodeUtf8 _v298))) <$> timResponseBean_threadId record
  , (\_v298 -> (2, ("error",from_TimError _v298))) <$> timResponseBean_error record
  , (\_v298 -> (3, ("extraList",T.TList (T.T_STRUCT typemap_TimNode) $ P.map (\_v300 -> from_TimNode _v300) $ Vector.toList _v298))) <$> timResponseBean_extraList record
  , (\_v298 -> (4, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k301,_v302) -> (T.TString $ E.encodeUtf8 _k301, T.TString $ E.encodeUtf8 _v302)) $ Map.toList _v298))) <$> timResponseBean_extraMap record
  ]
write_TimResponseBean :: (T.Protocol p, T.Transport t) => p t -> TimResponseBean -> P.IO ()
write_TimResponseBean oprot record = T.writeVal oprot $ from_TimResponseBean record
encode_TimResponseBean :: (T.Protocol p, T.Transport t) => p t -> TimResponseBean -> LBS.ByteString
encode_TimResponseBean oprot record = T.serializeVal oprot $ from_TimResponseBean record
to_TimResponseBean :: T.ThriftVal -> TimResponseBean
to_TimResponseBean (T.TStruct fields) = TimResponseBean{
  timResponseBean_threadId = P.maybe (P.Nothing) (\(_,_val304) -> P.Just (case _val304 of {T.TString _val305 -> E.decodeUtf8 _val305; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timResponseBean_error = P.maybe (P.Nothing) (\(_,_val304) -> P.Just (case _val304 of {T.TStruct _val306 -> (to_TimError (T.TStruct _val306)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timResponseBean_extraList = P.maybe (P.Nothing) (\(_,_val304) -> P.Just (case _val304 of {T.TList _ _val307 -> (Vector.fromList $ P.map (\_v308 -> (case _v308 of {T.TStruct _val309 -> (to_TimNode (T.TStruct _val309)); _ -> P.error "wrong type"})) _val307); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  timResponseBean_extraMap = P.maybe (P.Nothing) (\(_,_val304) -> P.Just (case _val304 of {T.TMap _ _ _val310 -> (Map.fromList $ P.map (\(_k312,_v311) -> ((case _k312 of {T.TString _val313 -> E.decodeUtf8 _val313; _ -> P.error "wrong type"}),(case _v311 of {T.TString _val314 -> E.decodeUtf8 _val314; _ -> P.error "wrong type"}))) _val310); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_TimResponseBean _ = P.error "not a struct"
read_TimResponseBean :: (T.Transport t, T.Protocol p) => p t -> P.IO TimResponseBean
read_TimResponseBean iprot = to_TimResponseBean <$> T.readVal iprot (T.T_STRUCT typemap_TimResponseBean)
decode_TimResponseBean :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimResponseBean
decode_TimResponseBean iprot bs = to_TimResponseBean $ T.deserializeVal iprot (T.T_STRUCT typemap_TimResponseBean) bs
typemap_TimResponseBean :: T.TypeMap
typemap_TimResponseBean = Map.fromList [(1,("threadId",T.T_STRING)),(2,("error",(T.T_STRUCT typemap_TimError))),(3,("extraList",(T.T_LIST (T.T_STRUCT typemap_TimNode)))),(4,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TimResponseBean :: TimResponseBean
default_TimResponseBean = TimResponseBean{
  timResponseBean_threadId = P.Nothing,
  timResponseBean_error = P.Nothing,
  timResponseBean_extraList = P.Nothing,
  timResponseBean_extraMap = P.Nothing}
data TimSock5Bean = TimSock5Bean  { timSock5Bean_fromTid :: Tid
  , timSock5Bean_toTid :: Tid
  , timSock5Bean_addr :: LT.Text
  , timSock5Bean_port :: I.Int32
  , timSock5Bean_transport :: I.Int16
  , timSock5Bean_pubId :: LT.Text
  , timSock5Bean_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimSock5Bean where
  hashWithSalt salt record = salt   `H.hashWithSalt` timSock5Bean_fromTid record   `H.hashWithSalt` timSock5Bean_toTid record   `H.hashWithSalt` timSock5Bean_addr record   `H.hashWithSalt` timSock5Bean_port record   `H.hashWithSalt` timSock5Bean_transport record   `H.hashWithSalt` timSock5Bean_pubId record   `H.hashWithSalt` timSock5Bean_extraMap record  
instance QC.Arbitrary TimSock5Bean where 
  arbitrary = M.liftM TimSock5Bean (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimSock5Bean = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimSock5Bean{timSock5Bean_fromTid = timSock5Bean_fromTid obj} then P.Nothing else P.Just $ default_TimSock5Bean{timSock5Bean_fromTid = timSock5Bean_fromTid obj}
    , if obj == default_TimSock5Bean{timSock5Bean_toTid = timSock5Bean_toTid obj} then P.Nothing else P.Just $ default_TimSock5Bean{timSock5Bean_toTid = timSock5Bean_toTid obj}
    , if obj == default_TimSock5Bean{timSock5Bean_addr = timSock5Bean_addr obj} then P.Nothing else P.Just $ default_TimSock5Bean{timSock5Bean_addr = timSock5Bean_addr obj}
    , if obj == default_TimSock5Bean{timSock5Bean_port = timSock5Bean_port obj} then P.Nothing else P.Just $ default_TimSock5Bean{timSock5Bean_port = timSock5Bean_port obj}
    , if obj == default_TimSock5Bean{timSock5Bean_transport = timSock5Bean_transport obj} then P.Nothing else P.Just $ default_TimSock5Bean{timSock5Bean_transport = timSock5Bean_transport obj}
    , if obj == default_TimSock5Bean{timSock5Bean_pubId = timSock5Bean_pubId obj} then P.Nothing else P.Just $ default_TimSock5Bean{timSock5Bean_pubId = timSock5Bean_pubId obj}
    , if obj == default_TimSock5Bean{timSock5Bean_extraMap = timSock5Bean_extraMap obj} then P.Nothing else P.Just $ default_TimSock5Bean{timSock5Bean_extraMap = timSock5Bean_extraMap obj}
    ]
from_TimSock5Bean :: TimSock5Bean -> T.ThriftVal
from_TimSock5Bean record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v317 -> P.Just (1, ("fromTid",from_Tid _v317))) $ timSock5Bean_fromTid record
  , (\_v317 -> P.Just (2, ("toTid",from_Tid _v317))) $ timSock5Bean_toTid record
  , (\_v317 -> P.Just (3, ("addr",T.TString $ E.encodeUtf8 _v317))) $ timSock5Bean_addr record
  , (\_v317 -> P.Just (4, ("port",T.TI32 _v317))) $ timSock5Bean_port record
  , (\_v317 -> P.Just (5, ("transport",T.TI16 _v317))) $ timSock5Bean_transport record
  , (\_v317 -> P.Just (6, ("pubId",T.TString $ E.encodeUtf8 _v317))) $ timSock5Bean_pubId record
  , (\_v317 -> (7, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k318,_v319) -> (T.TString $ E.encodeUtf8 _k318, T.TString $ E.encodeUtf8 _v319)) $ Map.toList _v317))) <$> timSock5Bean_extraMap record
  ]
write_TimSock5Bean :: (T.Protocol p, T.Transport t) => p t -> TimSock5Bean -> P.IO ()
write_TimSock5Bean oprot record = T.writeVal oprot $ from_TimSock5Bean record
encode_TimSock5Bean :: (T.Protocol p, T.Transport t) => p t -> TimSock5Bean -> LBS.ByteString
encode_TimSock5Bean oprot record = T.serializeVal oprot $ from_TimSock5Bean record
to_TimSock5Bean :: T.ThriftVal -> TimSock5Bean
to_TimSock5Bean (T.TStruct fields) = TimSock5Bean{
  timSock5Bean_fromTid = P.maybe (P.error "Missing required field: fromTid") (\(_,_val321) -> (case _val321 of {T.TStruct _val322 -> (to_Tid (T.TStruct _val322)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timSock5Bean_toTid = P.maybe (P.error "Missing required field: toTid") (\(_,_val321) -> (case _val321 of {T.TStruct _val323 -> (to_Tid (T.TStruct _val323)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timSock5Bean_addr = P.maybe (P.error "Missing required field: addr") (\(_,_val321) -> (case _val321 of {T.TString _val324 -> E.decodeUtf8 _val324; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  timSock5Bean_port = P.maybe (P.error "Missing required field: port") (\(_,_val321) -> (case _val321 of {T.TI32 _val325 -> _val325; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  timSock5Bean_transport = P.maybe (P.error "Missing required field: transport") (\(_,_val321) -> (case _val321 of {T.TI16 _val326 -> _val326; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  timSock5Bean_pubId = P.maybe (P.error "Missing required field: pubId") (\(_,_val321) -> (case _val321 of {T.TString _val327 -> E.decodeUtf8 _val327; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  timSock5Bean_extraMap = P.maybe (P.Nothing) (\(_,_val321) -> P.Just (case _val321 of {T.TMap _ _ _val328 -> (Map.fromList $ P.map (\(_k330,_v329) -> ((case _k330 of {T.TString _val331 -> E.decodeUtf8 _val331; _ -> P.error "wrong type"}),(case _v329 of {T.TString _val332 -> E.decodeUtf8 _val332; _ -> P.error "wrong type"}))) _val328); _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_TimSock5Bean _ = P.error "not a struct"
read_TimSock5Bean :: (T.Transport t, T.Protocol p) => p t -> P.IO TimSock5Bean
read_TimSock5Bean iprot = to_TimSock5Bean <$> T.readVal iprot (T.T_STRUCT typemap_TimSock5Bean)
decode_TimSock5Bean :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimSock5Bean
decode_TimSock5Bean iprot bs = to_TimSock5Bean $ T.deserializeVal iprot (T.T_STRUCT typemap_TimSock5Bean) bs
typemap_TimSock5Bean :: T.TypeMap
typemap_TimSock5Bean = Map.fromList [(1,("fromTid",(T.T_STRUCT typemap_Tid))),(2,("toTid",(T.T_STRUCT typemap_Tid))),(3,("addr",T.T_STRING)),(4,("port",T.T_I32)),(5,("transport",T.T_I16)),(6,("pubId",T.T_STRING)),(7,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TimSock5Bean :: TimSock5Bean
default_TimSock5Bean = TimSock5Bean{
  timSock5Bean_fromTid = default_Tid,
  timSock5Bean_toTid = default_Tid,
  timSock5Bean_addr = "",
  timSock5Bean_port = 0,
  timSock5Bean_transport = 0,
  timSock5Bean_pubId = "",
  timSock5Bean_extraMap = P.Nothing}
data TimSock5Bytes = TimSock5Bytes  { timSock5Bytes_pubId :: LT.Text
  , timSock5Bytes_index :: I.Int32
  , timSock5Bytes_bytes :: (Vector.Vector LBS.ByteString)
  , timSock5Bytes_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimSock5Bytes where
  hashWithSalt salt record = salt   `H.hashWithSalt` timSock5Bytes_pubId record   `H.hashWithSalt` timSock5Bytes_index record   `H.hashWithSalt` timSock5Bytes_bytes record   `H.hashWithSalt` timSock5Bytes_extraMap record  
instance QC.Arbitrary TimSock5Bytes where 
  arbitrary = M.liftM TimSock5Bytes (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimSock5Bytes = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimSock5Bytes{timSock5Bytes_pubId = timSock5Bytes_pubId obj} then P.Nothing else P.Just $ default_TimSock5Bytes{timSock5Bytes_pubId = timSock5Bytes_pubId obj}
    , if obj == default_TimSock5Bytes{timSock5Bytes_index = timSock5Bytes_index obj} then P.Nothing else P.Just $ default_TimSock5Bytes{timSock5Bytes_index = timSock5Bytes_index obj}
    , if obj == default_TimSock5Bytes{timSock5Bytes_bytes = timSock5Bytes_bytes obj} then P.Nothing else P.Just $ default_TimSock5Bytes{timSock5Bytes_bytes = timSock5Bytes_bytes obj}
    , if obj == default_TimSock5Bytes{timSock5Bytes_extraMap = timSock5Bytes_extraMap obj} then P.Nothing else P.Just $ default_TimSock5Bytes{timSock5Bytes_extraMap = timSock5Bytes_extraMap obj}
    ]
from_TimSock5Bytes :: TimSock5Bytes -> T.ThriftVal
from_TimSock5Bytes record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v335 -> P.Just (1, ("pubId",T.TString $ E.encodeUtf8 _v335))) $ timSock5Bytes_pubId record
  , (\_v335 -> P.Just (2, ("index",T.TI32 _v335))) $ timSock5Bytes_index record
  , (\_v335 -> P.Just (3, ("bytes",T.TList T.T_STRING $ P.map (\_v337 -> T.TString _v337) $ Vector.toList _v335))) $ timSock5Bytes_bytes record
  , (\_v335 -> (4, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k338,_v339) -> (T.TString $ E.encodeUtf8 _k338, T.TString $ E.encodeUtf8 _v339)) $ Map.toList _v335))) <$> timSock5Bytes_extraMap record
  ]
write_TimSock5Bytes :: (T.Protocol p, T.Transport t) => p t -> TimSock5Bytes -> P.IO ()
write_TimSock5Bytes oprot record = T.writeVal oprot $ from_TimSock5Bytes record
encode_TimSock5Bytes :: (T.Protocol p, T.Transport t) => p t -> TimSock5Bytes -> LBS.ByteString
encode_TimSock5Bytes oprot record = T.serializeVal oprot $ from_TimSock5Bytes record
to_TimSock5Bytes :: T.ThriftVal -> TimSock5Bytes
to_TimSock5Bytes (T.TStruct fields) = TimSock5Bytes{
  timSock5Bytes_pubId = P.maybe (P.error "Missing required field: pubId") (\(_,_val341) -> (case _val341 of {T.TString _val342 -> E.decodeUtf8 _val342; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timSock5Bytes_index = P.maybe (P.error "Missing required field: index") (\(_,_val341) -> (case _val341 of {T.TI32 _val343 -> _val343; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timSock5Bytes_bytes = P.maybe (P.error "Missing required field: bytes") (\(_,_val341) -> (case _val341 of {T.TList _ _val344 -> (Vector.fromList $ P.map (\_v345 -> (case _v345 of {T.TString _val346 -> _val346; _ -> P.error "wrong type"})) _val344); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  timSock5Bytes_extraMap = P.maybe (P.Nothing) (\(_,_val341) -> P.Just (case _val341 of {T.TMap _ _ _val347 -> (Map.fromList $ P.map (\(_k349,_v348) -> ((case _k349 of {T.TString _val350 -> E.decodeUtf8 _val350; _ -> P.error "wrong type"}),(case _v348 of {T.TString _val351 -> E.decodeUtf8 _val351; _ -> P.error "wrong type"}))) _val347); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_TimSock5Bytes _ = P.error "not a struct"
read_TimSock5Bytes :: (T.Transport t, T.Protocol p) => p t -> P.IO TimSock5Bytes
read_TimSock5Bytes iprot = to_TimSock5Bytes <$> T.readVal iprot (T.T_STRUCT typemap_TimSock5Bytes)
decode_TimSock5Bytes :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimSock5Bytes
decode_TimSock5Bytes iprot bs = to_TimSock5Bytes $ T.deserializeVal iprot (T.T_STRUCT typemap_TimSock5Bytes) bs
typemap_TimSock5Bytes :: T.TypeMap
typemap_TimSock5Bytes = Map.fromList [(1,("pubId",T.T_STRING)),(2,("index",T.T_I32)),(3,("bytes",(T.T_LIST T.T_STRING))),(4,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TimSock5Bytes :: TimSock5Bytes
default_TimSock5Bytes = TimSock5Bytes{
  timSock5Bytes_pubId = "",
  timSock5Bytes_index = 0,
  timSock5Bytes_bytes = Vector.empty,
  timSock5Bytes_extraMap = P.Nothing}
data TimPage = TimPage  { timPage_fromTimeStamp :: P.Maybe LT.Text
  , timPage_toTimeStamp :: P.Maybe LT.Text
  , timPage_limitCount :: P.Maybe I.Int32
  , timPage_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimPage where
  hashWithSalt salt record = salt   `H.hashWithSalt` timPage_fromTimeStamp record   `H.hashWithSalt` timPage_toTimeStamp record   `H.hashWithSalt` timPage_limitCount record   `H.hashWithSalt` timPage_extraMap record  
instance QC.Arbitrary TimPage where 
  arbitrary = M.liftM TimPage (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimPage = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimPage{timPage_fromTimeStamp = timPage_fromTimeStamp obj} then P.Nothing else P.Just $ default_TimPage{timPage_fromTimeStamp = timPage_fromTimeStamp obj}
    , if obj == default_TimPage{timPage_toTimeStamp = timPage_toTimeStamp obj} then P.Nothing else P.Just $ default_TimPage{timPage_toTimeStamp = timPage_toTimeStamp obj}
    , if obj == default_TimPage{timPage_limitCount = timPage_limitCount obj} then P.Nothing else P.Just $ default_TimPage{timPage_limitCount = timPage_limitCount obj}
    , if obj == default_TimPage{timPage_extraMap = timPage_extraMap obj} then P.Nothing else P.Just $ default_TimPage{timPage_extraMap = timPage_extraMap obj}
    ]
from_TimPage :: TimPage -> T.ThriftVal
from_TimPage record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v354 -> (1, ("fromTimeStamp",T.TString $ E.encodeUtf8 _v354))) <$> timPage_fromTimeStamp record
  , (\_v354 -> (2, ("toTimeStamp",T.TString $ E.encodeUtf8 _v354))) <$> timPage_toTimeStamp record
  , (\_v354 -> (3, ("limitCount",T.TI32 _v354))) <$> timPage_limitCount record
  , (\_v354 -> (4, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k355,_v356) -> (T.TString $ E.encodeUtf8 _k355, T.TString $ E.encodeUtf8 _v356)) $ Map.toList _v354))) <$> timPage_extraMap record
  ]
write_TimPage :: (T.Protocol p, T.Transport t) => p t -> TimPage -> P.IO ()
write_TimPage oprot record = T.writeVal oprot $ from_TimPage record
encode_TimPage :: (T.Protocol p, T.Transport t) => p t -> TimPage -> LBS.ByteString
encode_TimPage oprot record = T.serializeVal oprot $ from_TimPage record
to_TimPage :: T.ThriftVal -> TimPage
to_TimPage (T.TStruct fields) = TimPage{
  timPage_fromTimeStamp = P.maybe (P.Nothing) (\(_,_val358) -> P.Just (case _val358 of {T.TString _val359 -> E.decodeUtf8 _val359; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timPage_toTimeStamp = P.maybe (P.Nothing) (\(_,_val358) -> P.Just (case _val358 of {T.TString _val360 -> E.decodeUtf8 _val360; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timPage_limitCount = P.maybe (P.Nothing) (\(_,_val358) -> P.Just (case _val358 of {T.TI32 _val361 -> _val361; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  timPage_extraMap = P.maybe (P.Nothing) (\(_,_val358) -> P.Just (case _val358 of {T.TMap _ _ _val362 -> (Map.fromList $ P.map (\(_k364,_v363) -> ((case _k364 of {T.TString _val365 -> E.decodeUtf8 _val365; _ -> P.error "wrong type"}),(case _v363 of {T.TString _val366 -> E.decodeUtf8 _val366; _ -> P.error "wrong type"}))) _val362); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_TimPage _ = P.error "not a struct"
read_TimPage :: (T.Transport t, T.Protocol p) => p t -> P.IO TimPage
read_TimPage iprot = to_TimPage <$> T.readVal iprot (T.T_STRUCT typemap_TimPage)
decode_TimPage :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimPage
decode_TimPage iprot bs = to_TimPage $ T.deserializeVal iprot (T.T_STRUCT typemap_TimPage) bs
typemap_TimPage :: T.TypeMap
typemap_TimPage = Map.fromList [(1,("fromTimeStamp",T.T_STRING)),(2,("toTimeStamp",T.T_STRING)),(3,("limitCount",T.T_I32)),(4,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TimPage :: TimPage
default_TimPage = TimPage{
  timPage_fromTimeStamp = P.Nothing,
  timPage_toTimeStamp = P.Nothing,
  timPage_limitCount = P.Nothing,
  timPage_extraMap = P.Nothing}
data TimMessageIq = TimMessageIq  { timMessageIq_tidlist :: P.Maybe (Vector.Vector LT.Text)
  , timMessageIq_timPage :: P.Maybe TimPage
  , timMessageIq_midlist :: P.Maybe (Vector.Vector LT.Text)
  , timMessageIq_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimMessageIq where
  hashWithSalt salt record = salt   `H.hashWithSalt` timMessageIq_tidlist record   `H.hashWithSalt` timMessageIq_timPage record   `H.hashWithSalt` timMessageIq_midlist record   `H.hashWithSalt` timMessageIq_extraMap record  
instance QC.Arbitrary TimMessageIq where 
  arbitrary = M.liftM TimMessageIq (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimMessageIq = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimMessageIq{timMessageIq_tidlist = timMessageIq_tidlist obj} then P.Nothing else P.Just $ default_TimMessageIq{timMessageIq_tidlist = timMessageIq_tidlist obj}
    , if obj == default_TimMessageIq{timMessageIq_timPage = timMessageIq_timPage obj} then P.Nothing else P.Just $ default_TimMessageIq{timMessageIq_timPage = timMessageIq_timPage obj}
    , if obj == default_TimMessageIq{timMessageIq_midlist = timMessageIq_midlist obj} then P.Nothing else P.Just $ default_TimMessageIq{timMessageIq_midlist = timMessageIq_midlist obj}
    , if obj == default_TimMessageIq{timMessageIq_extraMap = timMessageIq_extraMap obj} then P.Nothing else P.Just $ default_TimMessageIq{timMessageIq_extraMap = timMessageIq_extraMap obj}
    ]
from_TimMessageIq :: TimMessageIq -> T.ThriftVal
from_TimMessageIq record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v369 -> (1, ("tidlist",T.TList T.T_STRING $ P.map (\_v371 -> T.TString $ E.encodeUtf8 _v371) $ Vector.toList _v369))) <$> timMessageIq_tidlist record
  , (\_v369 -> (2, ("timPage",from_TimPage _v369))) <$> timMessageIq_timPage record
  , (\_v369 -> (3, ("midlist",T.TList T.T_STRING $ P.map (\_v373 -> T.TString $ E.encodeUtf8 _v373) $ Vector.toList _v369))) <$> timMessageIq_midlist record
  , (\_v369 -> (4, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k374,_v375) -> (T.TString $ E.encodeUtf8 _k374, T.TString $ E.encodeUtf8 _v375)) $ Map.toList _v369))) <$> timMessageIq_extraMap record
  ]
write_TimMessageIq :: (T.Protocol p, T.Transport t) => p t -> TimMessageIq -> P.IO ()
write_TimMessageIq oprot record = T.writeVal oprot $ from_TimMessageIq record
encode_TimMessageIq :: (T.Protocol p, T.Transport t) => p t -> TimMessageIq -> LBS.ByteString
encode_TimMessageIq oprot record = T.serializeVal oprot $ from_TimMessageIq record
to_TimMessageIq :: T.ThriftVal -> TimMessageIq
to_TimMessageIq (T.TStruct fields) = TimMessageIq{
  timMessageIq_tidlist = P.maybe (P.Nothing) (\(_,_val377) -> P.Just (case _val377 of {T.TList _ _val378 -> (Vector.fromList $ P.map (\_v379 -> (case _v379 of {T.TString _val380 -> E.decodeUtf8 _val380; _ -> P.error "wrong type"})) _val378); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timMessageIq_timPage = P.maybe (P.Nothing) (\(_,_val377) -> P.Just (case _val377 of {T.TStruct _val381 -> (to_TimPage (T.TStruct _val381)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timMessageIq_midlist = P.maybe (P.Nothing) (\(_,_val377) -> P.Just (case _val377 of {T.TList _ _val382 -> (Vector.fromList $ P.map (\_v383 -> (case _v383 of {T.TString _val384 -> E.decodeUtf8 _val384; _ -> P.error "wrong type"})) _val382); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  timMessageIq_extraMap = P.maybe (P.Nothing) (\(_,_val377) -> P.Just (case _val377 of {T.TMap _ _ _val385 -> (Map.fromList $ P.map (\(_k387,_v386) -> ((case _k387 of {T.TString _val388 -> E.decodeUtf8 _val388; _ -> P.error "wrong type"}),(case _v386 of {T.TString _val389 -> E.decodeUtf8 _val389; _ -> P.error "wrong type"}))) _val385); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_TimMessageIq _ = P.error "not a struct"
read_TimMessageIq :: (T.Transport t, T.Protocol p) => p t -> P.IO TimMessageIq
read_TimMessageIq iprot = to_TimMessageIq <$> T.readVal iprot (T.T_STRUCT typemap_TimMessageIq)
decode_TimMessageIq :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimMessageIq
decode_TimMessageIq iprot bs = to_TimMessageIq $ T.deserializeVal iprot (T.T_STRUCT typemap_TimMessageIq) bs
typemap_TimMessageIq :: T.TypeMap
typemap_TimMessageIq = Map.fromList [(1,("tidlist",(T.T_LIST T.T_STRING))),(2,("timPage",(T.T_STRUCT typemap_TimPage))),(3,("midlist",(T.T_LIST T.T_STRING))),(4,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TimMessageIq :: TimMessageIq
default_TimMessageIq = TimMessageIq{
  timMessageIq_tidlist = P.Nothing,
  timMessageIq_timPage = P.Nothing,
  timMessageIq_midlist = P.Nothing,
  timMessageIq_extraMap = P.Nothing}
data TimAuth = TimAuth  { timAuth_domain :: P.Maybe LT.Text
  , timAuth_username :: P.Maybe LT.Text
  , timAuth_pwd :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimAuth where
  hashWithSalt salt record = salt   `H.hashWithSalt` timAuth_domain record   `H.hashWithSalt` timAuth_username record   `H.hashWithSalt` timAuth_pwd record  
instance QC.Arbitrary TimAuth where 
  arbitrary = M.liftM TimAuth (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimAuth = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimAuth{timAuth_domain = timAuth_domain obj} then P.Nothing else P.Just $ default_TimAuth{timAuth_domain = timAuth_domain obj}
    , if obj == default_TimAuth{timAuth_username = timAuth_username obj} then P.Nothing else P.Just $ default_TimAuth{timAuth_username = timAuth_username obj}
    , if obj == default_TimAuth{timAuth_pwd = timAuth_pwd obj} then P.Nothing else P.Just $ default_TimAuth{timAuth_pwd = timAuth_pwd obj}
    ]
from_TimAuth :: TimAuth -> T.ThriftVal
from_TimAuth record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v392 -> (1, ("domain",T.TString $ E.encodeUtf8 _v392))) <$> timAuth_domain record
  , (\_v392 -> (2, ("username",T.TString $ E.encodeUtf8 _v392))) <$> timAuth_username record
  , (\_v392 -> (3, ("pwd",T.TString $ E.encodeUtf8 _v392))) <$> timAuth_pwd record
  ]
write_TimAuth :: (T.Protocol p, T.Transport t) => p t -> TimAuth -> P.IO ()
write_TimAuth oprot record = T.writeVal oprot $ from_TimAuth record
encode_TimAuth :: (T.Protocol p, T.Transport t) => p t -> TimAuth -> LBS.ByteString
encode_TimAuth oprot record = T.serializeVal oprot $ from_TimAuth record
to_TimAuth :: T.ThriftVal -> TimAuth
to_TimAuth (T.TStruct fields) = TimAuth{
  timAuth_domain = P.maybe (P.Nothing) (\(_,_val394) -> P.Just (case _val394 of {T.TString _val395 -> E.decodeUtf8 _val395; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timAuth_username = P.maybe (P.Nothing) (\(_,_val394) -> P.Just (case _val394 of {T.TString _val396 -> E.decodeUtf8 _val396; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timAuth_pwd = P.maybe (P.Nothing) (\(_,_val394) -> P.Just (case _val394 of {T.TString _val397 -> E.decodeUtf8 _val397; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_TimAuth _ = P.error "not a struct"
read_TimAuth :: (T.Transport t, T.Protocol p) => p t -> P.IO TimAuth
read_TimAuth iprot = to_TimAuth <$> T.readVal iprot (T.T_STRUCT typemap_TimAuth)
decode_TimAuth :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimAuth
decode_TimAuth iprot bs = to_TimAuth $ T.deserializeVal iprot (T.T_STRUCT typemap_TimAuth) bs
typemap_TimAuth :: T.TypeMap
typemap_TimAuth = Map.fromList [(1,("domain",T.T_STRING)),(2,("username",T.T_STRING)),(3,("pwd",T.T_STRING))]
default_TimAuth :: TimAuth
default_TimAuth = TimAuth{
  timAuth_domain = P.Nothing,
  timAuth_username = P.Nothing,
  timAuth_pwd = P.Nothing}
data TimMBeanList = TimMBeanList  { timMBeanList_threadId :: LT.Text
  , timMBeanList_timMBeanList :: P.Maybe (Vector.Vector TimMBean)
  , timMBeanList_reqType :: P.Maybe LT.Text
  , timMBeanList_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimMBeanList where
  hashWithSalt salt record = salt   `H.hashWithSalt` timMBeanList_threadId record   `H.hashWithSalt` timMBeanList_timMBeanList record   `H.hashWithSalt` timMBeanList_reqType record   `H.hashWithSalt` timMBeanList_extraMap record  
instance QC.Arbitrary TimMBeanList where 
  arbitrary = M.liftM TimMBeanList (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimMBeanList = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimMBeanList{timMBeanList_threadId = timMBeanList_threadId obj} then P.Nothing else P.Just $ default_TimMBeanList{timMBeanList_threadId = timMBeanList_threadId obj}
    , if obj == default_TimMBeanList{timMBeanList_timMBeanList = timMBeanList_timMBeanList obj} then P.Nothing else P.Just $ default_TimMBeanList{timMBeanList_timMBeanList = timMBeanList_timMBeanList obj}
    , if obj == default_TimMBeanList{timMBeanList_reqType = timMBeanList_reqType obj} then P.Nothing else P.Just $ default_TimMBeanList{timMBeanList_reqType = timMBeanList_reqType obj}
    , if obj == default_TimMBeanList{timMBeanList_extraMap = timMBeanList_extraMap obj} then P.Nothing else P.Just $ default_TimMBeanList{timMBeanList_extraMap = timMBeanList_extraMap obj}
    ]
from_TimMBeanList :: TimMBeanList -> T.ThriftVal
from_TimMBeanList record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v400 -> P.Just (1, ("threadId",T.TString $ E.encodeUtf8 _v400))) $ timMBeanList_threadId record
  , (\_v400 -> (2, ("timMBeanList",T.TList (T.T_STRUCT typemap_TimMBean) $ P.map (\_v402 -> from_TimMBean _v402) $ Vector.toList _v400))) <$> timMBeanList_timMBeanList record
  , (\_v400 -> (3, ("reqType",T.TString $ E.encodeUtf8 _v400))) <$> timMBeanList_reqType record
  , (\_v400 -> (4, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k403,_v404) -> (T.TString $ E.encodeUtf8 _k403, T.TString $ E.encodeUtf8 _v404)) $ Map.toList _v400))) <$> timMBeanList_extraMap record
  ]
write_TimMBeanList :: (T.Protocol p, T.Transport t) => p t -> TimMBeanList -> P.IO ()
write_TimMBeanList oprot record = T.writeVal oprot $ from_TimMBeanList record
encode_TimMBeanList :: (T.Protocol p, T.Transport t) => p t -> TimMBeanList -> LBS.ByteString
encode_TimMBeanList oprot record = T.serializeVal oprot $ from_TimMBeanList record
to_TimMBeanList :: T.ThriftVal -> TimMBeanList
to_TimMBeanList (T.TStruct fields) = TimMBeanList{
  timMBeanList_threadId = P.maybe (P.error "Missing required field: threadId") (\(_,_val406) -> (case _val406 of {T.TString _val407 -> E.decodeUtf8 _val407; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timMBeanList_timMBeanList = P.maybe (P.Nothing) (\(_,_val406) -> P.Just (case _val406 of {T.TList _ _val408 -> (Vector.fromList $ P.map (\_v409 -> (case _v409 of {T.TStruct _val410 -> (to_TimMBean (T.TStruct _val410)); _ -> P.error "wrong type"})) _val408); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timMBeanList_reqType = P.maybe (P.Nothing) (\(_,_val406) -> P.Just (case _val406 of {T.TString _val411 -> E.decodeUtf8 _val411; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  timMBeanList_extraMap = P.maybe (P.Nothing) (\(_,_val406) -> P.Just (case _val406 of {T.TMap _ _ _val412 -> (Map.fromList $ P.map (\(_k414,_v413) -> ((case _k414 of {T.TString _val415 -> E.decodeUtf8 _val415; _ -> P.error "wrong type"}),(case _v413 of {T.TString _val416 -> E.decodeUtf8 _val416; _ -> P.error "wrong type"}))) _val412); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_TimMBeanList _ = P.error "not a struct"
read_TimMBeanList :: (T.Transport t, T.Protocol p) => p t -> P.IO TimMBeanList
read_TimMBeanList iprot = to_TimMBeanList <$> T.readVal iprot (T.T_STRUCT typemap_TimMBeanList)
decode_TimMBeanList :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimMBeanList
decode_TimMBeanList iprot bs = to_TimMBeanList $ T.deserializeVal iprot (T.T_STRUCT typemap_TimMBeanList) bs
typemap_TimMBeanList :: T.TypeMap
typemap_TimMBeanList = Map.fromList [(1,("threadId",T.T_STRING)),(2,("timMBeanList",(T.T_LIST (T.T_STRUCT typemap_TimMBean)))),(3,("reqType",T.T_STRING)),(4,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TimMBeanList :: TimMBeanList
default_TimMBeanList = TimMBeanList{
  timMBeanList_threadId = "",
  timMBeanList_timMBeanList = P.Nothing,
  timMBeanList_reqType = P.Nothing,
  timMBeanList_extraMap = P.Nothing}
data TimPBeanList = TimPBeanList  { timPBeanList_threadId :: LT.Text
  , timPBeanList_timPBeanList :: P.Maybe (Vector.Vector TimPBean)
  , timPBeanList_reqType :: P.Maybe LT.Text
  , timPBeanList_extraMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimPBeanList where
  hashWithSalt salt record = salt   `H.hashWithSalt` timPBeanList_threadId record   `H.hashWithSalt` timPBeanList_timPBeanList record   `H.hashWithSalt` timPBeanList_reqType record   `H.hashWithSalt` timPBeanList_extraMap record  
instance QC.Arbitrary TimPBeanList where 
  arbitrary = M.liftM TimPBeanList (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimPBeanList = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimPBeanList{timPBeanList_threadId = timPBeanList_threadId obj} then P.Nothing else P.Just $ default_TimPBeanList{timPBeanList_threadId = timPBeanList_threadId obj}
    , if obj == default_TimPBeanList{timPBeanList_timPBeanList = timPBeanList_timPBeanList obj} then P.Nothing else P.Just $ default_TimPBeanList{timPBeanList_timPBeanList = timPBeanList_timPBeanList obj}
    , if obj == default_TimPBeanList{timPBeanList_reqType = timPBeanList_reqType obj} then P.Nothing else P.Just $ default_TimPBeanList{timPBeanList_reqType = timPBeanList_reqType obj}
    , if obj == default_TimPBeanList{timPBeanList_extraMap = timPBeanList_extraMap obj} then P.Nothing else P.Just $ default_TimPBeanList{timPBeanList_extraMap = timPBeanList_extraMap obj}
    ]
from_TimPBeanList :: TimPBeanList -> T.ThriftVal
from_TimPBeanList record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v419 -> P.Just (1, ("threadId",T.TString $ E.encodeUtf8 _v419))) $ timPBeanList_threadId record
  , (\_v419 -> (2, ("timPBeanList",T.TList (T.T_STRUCT typemap_TimPBean) $ P.map (\_v421 -> from_TimPBean _v421) $ Vector.toList _v419))) <$> timPBeanList_timPBeanList record
  , (\_v419 -> (3, ("reqType",T.TString $ E.encodeUtf8 _v419))) <$> timPBeanList_reqType record
  , (\_v419 -> (4, ("extraMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k422,_v423) -> (T.TString $ E.encodeUtf8 _k422, T.TString $ E.encodeUtf8 _v423)) $ Map.toList _v419))) <$> timPBeanList_extraMap record
  ]
write_TimPBeanList :: (T.Protocol p, T.Transport t) => p t -> TimPBeanList -> P.IO ()
write_TimPBeanList oprot record = T.writeVal oprot $ from_TimPBeanList record
encode_TimPBeanList :: (T.Protocol p, T.Transport t) => p t -> TimPBeanList -> LBS.ByteString
encode_TimPBeanList oprot record = T.serializeVal oprot $ from_TimPBeanList record
to_TimPBeanList :: T.ThriftVal -> TimPBeanList
to_TimPBeanList (T.TStruct fields) = TimPBeanList{
  timPBeanList_threadId = P.maybe (P.error "Missing required field: threadId") (\(_,_val425) -> (case _val425 of {T.TString _val426 -> E.decodeUtf8 _val426; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timPBeanList_timPBeanList = P.maybe (P.Nothing) (\(_,_val425) -> P.Just (case _val425 of {T.TList _ _val427 -> (Vector.fromList $ P.map (\_v428 -> (case _v428 of {T.TStruct _val429 -> (to_TimPBean (T.TStruct _val429)); _ -> P.error "wrong type"})) _val427); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timPBeanList_reqType = P.maybe (P.Nothing) (\(_,_val425) -> P.Just (case _val425 of {T.TString _val430 -> E.decodeUtf8 _val430; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  timPBeanList_extraMap = P.maybe (P.Nothing) (\(_,_val425) -> P.Just (case _val425 of {T.TMap _ _ _val431 -> (Map.fromList $ P.map (\(_k433,_v432) -> ((case _k433 of {T.TString _val434 -> E.decodeUtf8 _val434; _ -> P.error "wrong type"}),(case _v432 of {T.TString _val435 -> E.decodeUtf8 _val435; _ -> P.error "wrong type"}))) _val431); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_TimPBeanList _ = P.error "not a struct"
read_TimPBeanList :: (T.Transport t, T.Protocol p) => p t -> P.IO TimPBeanList
read_TimPBeanList iprot = to_TimPBeanList <$> T.readVal iprot (T.T_STRUCT typemap_TimPBeanList)
decode_TimPBeanList :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimPBeanList
decode_TimPBeanList iprot bs = to_TimPBeanList $ T.deserializeVal iprot (T.T_STRUCT typemap_TimPBeanList) bs
typemap_TimPBeanList :: T.TypeMap
typemap_TimPBeanList = Map.fromList [(1,("threadId",T.T_STRING)),(2,("timPBeanList",(T.T_LIST (T.T_STRUCT typemap_TimPBean)))),(3,("reqType",T.T_STRING)),(4,("extraMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TimPBeanList :: TimPBeanList
default_TimPBeanList = TimPBeanList{
  timPBeanList_threadId = "",
  timPBeanList_timPBeanList = P.Nothing,
  timPBeanList_reqType = P.Nothing,
  timPBeanList_extraMap = P.Nothing}
data TimPropertyBean = TimPropertyBean  { timPropertyBean_threadId :: P.Maybe LT.Text
  , timPropertyBean_interflow :: P.Maybe LT.Text
  , timPropertyBean_tls :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TimPropertyBean where
  hashWithSalt salt record = salt   `H.hashWithSalt` timPropertyBean_threadId record   `H.hashWithSalt` timPropertyBean_interflow record   `H.hashWithSalt` timPropertyBean_tls record  
instance QC.Arbitrary TimPropertyBean where 
  arbitrary = M.liftM TimPropertyBean (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TimPropertyBean = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TimPropertyBean{timPropertyBean_threadId = timPropertyBean_threadId obj} then P.Nothing else P.Just $ default_TimPropertyBean{timPropertyBean_threadId = timPropertyBean_threadId obj}
    , if obj == default_TimPropertyBean{timPropertyBean_interflow = timPropertyBean_interflow obj} then P.Nothing else P.Just $ default_TimPropertyBean{timPropertyBean_interflow = timPropertyBean_interflow obj}
    , if obj == default_TimPropertyBean{timPropertyBean_tls = timPropertyBean_tls obj} then P.Nothing else P.Just $ default_TimPropertyBean{timPropertyBean_tls = timPropertyBean_tls obj}
    ]
from_TimPropertyBean :: TimPropertyBean -> T.ThriftVal
from_TimPropertyBean record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v438 -> (1, ("threadId",T.TString $ E.encodeUtf8 _v438))) <$> timPropertyBean_threadId record
  , (\_v438 -> (2, ("interflow",T.TString $ E.encodeUtf8 _v438))) <$> timPropertyBean_interflow record
  , (\_v438 -> (3, ("tls",T.TString $ E.encodeUtf8 _v438))) <$> timPropertyBean_tls record
  ]
write_TimPropertyBean :: (T.Protocol p, T.Transport t) => p t -> TimPropertyBean -> P.IO ()
write_TimPropertyBean oprot record = T.writeVal oprot $ from_TimPropertyBean record
encode_TimPropertyBean :: (T.Protocol p, T.Transport t) => p t -> TimPropertyBean -> LBS.ByteString
encode_TimPropertyBean oprot record = T.serializeVal oprot $ from_TimPropertyBean record
to_TimPropertyBean :: T.ThriftVal -> TimPropertyBean
to_TimPropertyBean (T.TStruct fields) = TimPropertyBean{
  timPropertyBean_threadId = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TString _val441 -> E.decodeUtf8 _val441; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  timPropertyBean_interflow = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TString _val442 -> E.decodeUtf8 _val442; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  timPropertyBean_tls = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TString _val443 -> E.decodeUtf8 _val443; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_TimPropertyBean _ = P.error "not a struct"
read_TimPropertyBean :: (T.Transport t, T.Protocol p) => p t -> P.IO TimPropertyBean
read_TimPropertyBean iprot = to_TimPropertyBean <$> T.readVal iprot (T.T_STRUCT typemap_TimPropertyBean)
decode_TimPropertyBean :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> TimPropertyBean
decode_TimPropertyBean iprot bs = to_TimPropertyBean $ T.deserializeVal iprot (T.T_STRUCT typemap_TimPropertyBean) bs
typemap_TimPropertyBean :: T.TypeMap
typemap_TimPropertyBean = Map.fromList [(1,("threadId",T.T_STRING)),(2,("interflow",T.T_STRING)),(3,("tls",T.T_STRING))]
default_TimPropertyBean :: TimPropertyBean
default_TimPropertyBean = TimPropertyBean{
  timPropertyBean_threadId = P.Nothing,
  timPropertyBean_interflow = P.Nothing,
  timPropertyBean_tls = P.Nothing}
