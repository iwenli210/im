#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import logging
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def timStream(self, param):
    """
    流程开始

    Parameters:
     - param
    """
    pass

  def timStarttls(self):
    """
    tls协议
    """
    pass

  def timLogin(self, tid, pwd):
    """
    登陆协议

    Parameters:
     - tid
     - pwd
    """
    pass

  def timAck(self, ab):
    """
    回执信息

    Parameters:
     - ab
    """
    pass

  def timPresence(self, pbean):
    """
    广播出席协议或接收广播协议

    Parameters:
     - pbean
    """
    pass

  def timMessage(self, mbean):
    """
    发送信息或接收信息

    Parameters:
     - mbean
    """
    pass

  def timPing(self, threadId):
    """
    ping 心跳协议

    Parameters:
     - threadId
    """
    pass

  def timError(self, e):
    """
    错误通知

    Parameters:
     - e
    """
    pass

  def timLogout(self):
    """
    登出协议
    """
    pass

  def timRegist(self, tid, auth):
    """
    注册协议

    Parameters:
     - tid
     - auth
    """
    pass

  def timRoser(self, roster):
    """
    花名册

    Parameters:
     - roster
    """
    pass

  def timMessageList(self, mbeanList):
    """
    发送信息或接收信息列表（合流）

    Parameters:
     - mbeanList
    """
    pass

  def timPresenceList(self, pbeanList):
    """
    发送状态信息列表（合流）

    Parameters:
     - pbeanList
    """
    pass

  def timMessageIq(self, timMsgIq, iqType):
    """
    信息请求 get请求数据 del删除

    Parameters:
     - timMsgIq
     - iqType
    """
    pass

  def timMessageResult(self, mbean):
    """
    信息请求

    Parameters:
     - mbean
    """
    pass

  def timProperty(self, tpb):
    """
    用户协议属性请求

    Parameters:
     - tpb
    """
    pass

  def timRemoteUserAuth(self, tid, pwd, auth):
    """
    请求远程验证信息

    Parameters:
     - tid
     - pwd
     - auth
    """
    pass

  def timRemoteUserGet(self, tid, auth):
    """
    请求远程用户信息

    Parameters:
     - tid
     - auth
    """
    pass

  def timRemoteUserEdit(self, tid, ub, auth):
    """
    编辑远程用户信息

    Parameters:
     - tid
     - ub
     - auth
    """
    pass

  def timResponsePresence(self, pbean, auth):
    """
    广播出席协议或接收广播协议

    Parameters:
     - pbean
     - auth
    """
    pass

  def timResponseMessage(self, mbean, auth):
    """
    发送信息或接收信息

    Parameters:
     - mbean
     - auth
    """
    pass

  def timResponseMessageIq(self, timMsgIq, iqType, auth):
    """
    信息请求 get请求数据 del删除（辅助接口）

    Parameters:
     - timMsgIq
     - iqType
     - auth
    """
    pass

  def timResponsePresenceList(self, pbeanList, auth):
    """
    广播出席协议或接收广播协议

    Parameters:
     - pbeanList
     - auth
    """
    pass

  def timResponseMessageList(self, mbeanList, auth):
    """
    发送信息或接收信息

    Parameters:
     - mbeanList
     - auth
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def timStream(self, param):
    """
    流程开始

    Parameters:
     - param
    """
    self.send_timStream(param)

  def send_timStream(self, param):
    self._oprot.writeMessageBegin('timStream', TMessageType.ONEWAY, self._seqid)
    args = timStream_args()
    args.param = param
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def timStarttls(self):
    """
    tls协议
    """
    self.send_timStarttls()

  def send_timStarttls(self):
    self._oprot.writeMessageBegin('timStarttls', TMessageType.ONEWAY, self._seqid)
    args = timStarttls_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def timLogin(self, tid, pwd):
    """
    登陆协议

    Parameters:
     - tid
     - pwd
    """
    self.send_timLogin(tid, pwd)

  def send_timLogin(self, tid, pwd):
    self._oprot.writeMessageBegin('timLogin', TMessageType.ONEWAY, self._seqid)
    args = timLogin_args()
    args.tid = tid
    args.pwd = pwd
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def timAck(self, ab):
    """
    回执信息

    Parameters:
     - ab
    """
    self.send_timAck(ab)

  def send_timAck(self, ab):
    self._oprot.writeMessageBegin('timAck', TMessageType.ONEWAY, self._seqid)
    args = timAck_args()
    args.ab = ab
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def timPresence(self, pbean):
    """
    广播出席协议或接收广播协议

    Parameters:
     - pbean
    """
    self.send_timPresence(pbean)

  def send_timPresence(self, pbean):
    self._oprot.writeMessageBegin('timPresence', TMessageType.ONEWAY, self._seqid)
    args = timPresence_args()
    args.pbean = pbean
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def timMessage(self, mbean):
    """
    发送信息或接收信息

    Parameters:
     - mbean
    """
    self.send_timMessage(mbean)

  def send_timMessage(self, mbean):
    self._oprot.writeMessageBegin('timMessage', TMessageType.ONEWAY, self._seqid)
    args = timMessage_args()
    args.mbean = mbean
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def timPing(self, threadId):
    """
    ping 心跳协议

    Parameters:
     - threadId
    """
    self.send_timPing(threadId)

  def send_timPing(self, threadId):
    self._oprot.writeMessageBegin('timPing', TMessageType.ONEWAY, self._seqid)
    args = timPing_args()
    args.threadId = threadId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def timError(self, e):
    """
    错误通知

    Parameters:
     - e
    """
    self.send_timError(e)

  def send_timError(self, e):
    self._oprot.writeMessageBegin('timError', TMessageType.ONEWAY, self._seqid)
    args = timError_args()
    args.e = e
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def timLogout(self):
    """
    登出协议
    """
    self.send_timLogout()

  def send_timLogout(self):
    self._oprot.writeMessageBegin('timLogout', TMessageType.ONEWAY, self._seqid)
    args = timLogout_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def timRegist(self, tid, auth):
    """
    注册协议

    Parameters:
     - tid
     - auth
    """
    self.send_timRegist(tid, auth)

  def send_timRegist(self, tid, auth):
    self._oprot.writeMessageBegin('timRegist', TMessageType.ONEWAY, self._seqid)
    args = timRegist_args()
    args.tid = tid
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def timRoser(self, roster):
    """
    花名册

    Parameters:
     - roster
    """
    self.send_timRoser(roster)

  def send_timRoser(self, roster):
    self._oprot.writeMessageBegin('timRoser', TMessageType.ONEWAY, self._seqid)
    args = timRoser_args()
    args.roster = roster
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def timMessageList(self, mbeanList):
    """
    发送信息或接收信息列表（合流）

    Parameters:
     - mbeanList
    """
    self.send_timMessageList(mbeanList)

  def send_timMessageList(self, mbeanList):
    self._oprot.writeMessageBegin('timMessageList', TMessageType.ONEWAY, self._seqid)
    args = timMessageList_args()
    args.mbeanList = mbeanList
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def timPresenceList(self, pbeanList):
    """
    发送状态信息列表（合流）

    Parameters:
     - pbeanList
    """
    self.send_timPresenceList(pbeanList)

  def send_timPresenceList(self, pbeanList):
    self._oprot.writeMessageBegin('timPresenceList', TMessageType.ONEWAY, self._seqid)
    args = timPresenceList_args()
    args.pbeanList = pbeanList
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def timMessageIq(self, timMsgIq, iqType):
    """
    信息请求 get请求数据 del删除

    Parameters:
     - timMsgIq
     - iqType
    """
    self.send_timMessageIq(timMsgIq, iqType)

  def send_timMessageIq(self, timMsgIq, iqType):
    self._oprot.writeMessageBegin('timMessageIq', TMessageType.ONEWAY, self._seqid)
    args = timMessageIq_args()
    args.timMsgIq = timMsgIq
    args.iqType = iqType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def timMessageResult(self, mbean):
    """
    信息请求

    Parameters:
     - mbean
    """
    self.send_timMessageResult(mbean)

  def send_timMessageResult(self, mbean):
    self._oprot.writeMessageBegin('timMessageResult', TMessageType.ONEWAY, self._seqid)
    args = timMessageResult_args()
    args.mbean = mbean
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def timProperty(self, tpb):
    """
    用户协议属性请求

    Parameters:
     - tpb
    """
    self.send_timProperty(tpb)

  def send_timProperty(self, tpb):
    self._oprot.writeMessageBegin('timProperty', TMessageType.ONEWAY, self._seqid)
    args = timProperty_args()
    args.tpb = tpb
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def timRemoteUserAuth(self, tid, pwd, auth):
    """
    请求远程验证信息

    Parameters:
     - tid
     - pwd
     - auth
    """
    self.send_timRemoteUserAuth(tid, pwd, auth)
    return self.recv_timRemoteUserAuth()

  def send_timRemoteUserAuth(self, tid, pwd, auth):
    self._oprot.writeMessageBegin('timRemoteUserAuth', TMessageType.CALL, self._seqid)
    args = timRemoteUserAuth_args()
    args.tid = tid
    args.pwd = pwd
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_timRemoteUserAuth(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = timRemoteUserAuth_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "timRemoteUserAuth failed: unknown result")

  def timRemoteUserGet(self, tid, auth):
    """
    请求远程用户信息

    Parameters:
     - tid
     - auth
    """
    self.send_timRemoteUserGet(tid, auth)
    return self.recv_timRemoteUserGet()

  def send_timRemoteUserGet(self, tid, auth):
    self._oprot.writeMessageBegin('timRemoteUserGet', TMessageType.CALL, self._seqid)
    args = timRemoteUserGet_args()
    args.tid = tid
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_timRemoteUserGet(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = timRemoteUserGet_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "timRemoteUserGet failed: unknown result")

  def timRemoteUserEdit(self, tid, ub, auth):
    """
    编辑远程用户信息

    Parameters:
     - tid
     - ub
     - auth
    """
    self.send_timRemoteUserEdit(tid, ub, auth)
    return self.recv_timRemoteUserEdit()

  def send_timRemoteUserEdit(self, tid, ub, auth):
    self._oprot.writeMessageBegin('timRemoteUserEdit', TMessageType.CALL, self._seqid)
    args = timRemoteUserEdit_args()
    args.tid = tid
    args.ub = ub
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_timRemoteUserEdit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = timRemoteUserEdit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "timRemoteUserEdit failed: unknown result")

  def timResponsePresence(self, pbean, auth):
    """
    广播出席协议或接收广播协议

    Parameters:
     - pbean
     - auth
    """
    self.send_timResponsePresence(pbean, auth)
    return self.recv_timResponsePresence()

  def send_timResponsePresence(self, pbean, auth):
    self._oprot.writeMessageBegin('timResponsePresence', TMessageType.CALL, self._seqid)
    args = timResponsePresence_args()
    args.pbean = pbean
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_timResponsePresence(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = timResponsePresence_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "timResponsePresence failed: unknown result")

  def timResponseMessage(self, mbean, auth):
    """
    发送信息或接收信息

    Parameters:
     - mbean
     - auth
    """
    self.send_timResponseMessage(mbean, auth)
    return self.recv_timResponseMessage()

  def send_timResponseMessage(self, mbean, auth):
    self._oprot.writeMessageBegin('timResponseMessage', TMessageType.CALL, self._seqid)
    args = timResponseMessage_args()
    args.mbean = mbean
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_timResponseMessage(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = timResponseMessage_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "timResponseMessage failed: unknown result")

  def timResponseMessageIq(self, timMsgIq, iqType, auth):
    """
    信息请求 get请求数据 del删除（辅助接口）

    Parameters:
     - timMsgIq
     - iqType
     - auth
    """
    self.send_timResponseMessageIq(timMsgIq, iqType, auth)
    return self.recv_timResponseMessageIq()

  def send_timResponseMessageIq(self, timMsgIq, iqType, auth):
    self._oprot.writeMessageBegin('timResponseMessageIq', TMessageType.CALL, self._seqid)
    args = timResponseMessageIq_args()
    args.timMsgIq = timMsgIq
    args.iqType = iqType
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_timResponseMessageIq(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = timResponseMessageIq_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "timResponseMessageIq failed: unknown result")

  def timResponsePresenceList(self, pbeanList, auth):
    """
    广播出席协议或接收广播协议

    Parameters:
     - pbeanList
     - auth
    """
    self.send_timResponsePresenceList(pbeanList, auth)
    return self.recv_timResponsePresenceList()

  def send_timResponsePresenceList(self, pbeanList, auth):
    self._oprot.writeMessageBegin('timResponsePresenceList', TMessageType.CALL, self._seqid)
    args = timResponsePresenceList_args()
    args.pbeanList = pbeanList
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_timResponsePresenceList(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = timResponsePresenceList_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "timResponsePresenceList failed: unknown result")

  def timResponseMessageList(self, mbeanList, auth):
    """
    发送信息或接收信息

    Parameters:
     - mbeanList
     - auth
    """
    self.send_timResponseMessageList(mbeanList, auth)
    return self.recv_timResponseMessageList()

  def send_timResponseMessageList(self, mbeanList, auth):
    self._oprot.writeMessageBegin('timResponseMessageList', TMessageType.CALL, self._seqid)
    args = timResponseMessageList_args()
    args.mbeanList = mbeanList
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_timResponseMessageList(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = timResponseMessageList_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "timResponseMessageList failed: unknown result")


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["timStream"] = Processor.process_timStream
    self._processMap["timStarttls"] = Processor.process_timStarttls
    self._processMap["timLogin"] = Processor.process_timLogin
    self._processMap["timAck"] = Processor.process_timAck
    self._processMap["timPresence"] = Processor.process_timPresence
    self._processMap["timMessage"] = Processor.process_timMessage
    self._processMap["timPing"] = Processor.process_timPing
    self._processMap["timError"] = Processor.process_timError
    self._processMap["timLogout"] = Processor.process_timLogout
    self._processMap["timRegist"] = Processor.process_timRegist
    self._processMap["timRoser"] = Processor.process_timRoser
    self._processMap["timMessageList"] = Processor.process_timMessageList
    self._processMap["timPresenceList"] = Processor.process_timPresenceList
    self._processMap["timMessageIq"] = Processor.process_timMessageIq
    self._processMap["timMessageResult"] = Processor.process_timMessageResult
    self._processMap["timProperty"] = Processor.process_timProperty
    self._processMap["timRemoteUserAuth"] = Processor.process_timRemoteUserAuth
    self._processMap["timRemoteUserGet"] = Processor.process_timRemoteUserGet
    self._processMap["timRemoteUserEdit"] = Processor.process_timRemoteUserEdit
    self._processMap["timResponsePresence"] = Processor.process_timResponsePresence
    self._processMap["timResponseMessage"] = Processor.process_timResponseMessage
    self._processMap["timResponseMessageIq"] = Processor.process_timResponseMessageIq
    self._processMap["timResponsePresenceList"] = Processor.process_timResponsePresenceList
    self._processMap["timResponseMessageList"] = Processor.process_timResponseMessageList

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_timStream(self, seqid, iprot, oprot):
    args = timStream_args()
    args.read(iprot)
    iprot.readMessageEnd()
    try:
      self._handler.timStream(args.param)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except:
      pass

  def process_timStarttls(self, seqid, iprot, oprot):
    args = timStarttls_args()
    args.read(iprot)
    iprot.readMessageEnd()
    try:
      self._handler.timStarttls()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except:
      pass

  def process_timLogin(self, seqid, iprot, oprot):
    args = timLogin_args()
    args.read(iprot)
    iprot.readMessageEnd()
    try:
      self._handler.timLogin(args.tid, args.pwd)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except:
      pass

  def process_timAck(self, seqid, iprot, oprot):
    args = timAck_args()
    args.read(iprot)
    iprot.readMessageEnd()
    try:
      self._handler.timAck(args.ab)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except:
      pass

  def process_timPresence(self, seqid, iprot, oprot):
    args = timPresence_args()
    args.read(iprot)
    iprot.readMessageEnd()
    try:
      self._handler.timPresence(args.pbean)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except:
      pass

  def process_timMessage(self, seqid, iprot, oprot):
    args = timMessage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    try:
      self._handler.timMessage(args.mbean)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except:
      pass

  def process_timPing(self, seqid, iprot, oprot):
    args = timPing_args()
    args.read(iprot)
    iprot.readMessageEnd()
    try:
      self._handler.timPing(args.threadId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except:
      pass

  def process_timError(self, seqid, iprot, oprot):
    args = timError_args()
    args.read(iprot)
    iprot.readMessageEnd()
    try:
      self._handler.timError(args.e)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except:
      pass

  def process_timLogout(self, seqid, iprot, oprot):
    args = timLogout_args()
    args.read(iprot)
    iprot.readMessageEnd()
    try:
      self._handler.timLogout()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except:
      pass

  def process_timRegist(self, seqid, iprot, oprot):
    args = timRegist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    try:
      self._handler.timRegist(args.tid, args.auth)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except:
      pass

  def process_timRoser(self, seqid, iprot, oprot):
    args = timRoser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    try:
      self._handler.timRoser(args.roster)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except:
      pass

  def process_timMessageList(self, seqid, iprot, oprot):
    args = timMessageList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    try:
      self._handler.timMessageList(args.mbeanList)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except:
      pass

  def process_timPresenceList(self, seqid, iprot, oprot):
    args = timPresenceList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    try:
      self._handler.timPresenceList(args.pbeanList)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except:
      pass

  def process_timMessageIq(self, seqid, iprot, oprot):
    args = timMessageIq_args()
    args.read(iprot)
    iprot.readMessageEnd()
    try:
      self._handler.timMessageIq(args.timMsgIq, args.iqType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except:
      pass

  def process_timMessageResult(self, seqid, iprot, oprot):
    args = timMessageResult_args()
    args.read(iprot)
    iprot.readMessageEnd()
    try:
      self._handler.timMessageResult(args.mbean)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except:
      pass

  def process_timProperty(self, seqid, iprot, oprot):
    args = timProperty_args()
    args.read(iprot)
    iprot.readMessageEnd()
    try:
      self._handler.timProperty(args.tpb)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except:
      pass

  def process_timRemoteUserAuth(self, seqid, iprot, oprot):
    args = timRemoteUserAuth_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = timRemoteUserAuth_result()
    try:
      result.success = self._handler.timRemoteUserAuth(args.tid, args.pwd, args.auth)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("timRemoteUserAuth", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_timRemoteUserGet(self, seqid, iprot, oprot):
    args = timRemoteUserGet_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = timRemoteUserGet_result()
    try:
      result.success = self._handler.timRemoteUserGet(args.tid, args.auth)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("timRemoteUserGet", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_timRemoteUserEdit(self, seqid, iprot, oprot):
    args = timRemoteUserEdit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = timRemoteUserEdit_result()
    try:
      result.success = self._handler.timRemoteUserEdit(args.tid, args.ub, args.auth)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("timRemoteUserEdit", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_timResponsePresence(self, seqid, iprot, oprot):
    args = timResponsePresence_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = timResponsePresence_result()
    try:
      result.success = self._handler.timResponsePresence(args.pbean, args.auth)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("timResponsePresence", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_timResponseMessage(self, seqid, iprot, oprot):
    args = timResponseMessage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = timResponseMessage_result()
    try:
      result.success = self._handler.timResponseMessage(args.mbean, args.auth)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("timResponseMessage", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_timResponseMessageIq(self, seqid, iprot, oprot):
    args = timResponseMessageIq_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = timResponseMessageIq_result()
    try:
      result.success = self._handler.timResponseMessageIq(args.timMsgIq, args.iqType, args.auth)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("timResponseMessageIq", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_timResponsePresenceList(self, seqid, iprot, oprot):
    args = timResponsePresenceList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = timResponsePresenceList_result()
    try:
      result.success = self._handler.timResponsePresenceList(args.pbeanList, args.auth)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("timResponsePresenceList", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_timResponseMessageList(self, seqid, iprot, oprot):
    args = timResponseMessageList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = timResponseMessageList_result()
    try:
      result.success = self._handler.timResponseMessageList(args.mbeanList, args.auth)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("timResponseMessageList", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class timStream_args:
  """
  Attributes:
   - param
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'param', (TimParam, TimParam.thrift_spec), None, ), # 1
  )

  def __init__(self, param=None,):
    self.param = param

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.param = TimParam()
          self.param.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timStream_args')
    if self.param is not None:
      oprot.writeFieldBegin('param', TType.STRUCT, 1)
      self.param.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.param)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timStarttls_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timStarttls_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timLogin_args:
  """
  Attributes:
   - tid
   - pwd
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tid', (Tid, Tid.thrift_spec), None, ), # 1
    (2, TType.STRING, 'pwd', None, None, ), # 2
  )

  def __init__(self, tid=None, pwd=None,):
    self.tid = tid
    self.pwd = pwd

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tid = Tid()
          self.tid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pwd = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timLogin_args')
    if self.tid is not None:
      oprot.writeFieldBegin('tid', TType.STRUCT, 1)
      self.tid.write(oprot)
      oprot.writeFieldEnd()
    if self.pwd is not None:
      oprot.writeFieldBegin('pwd', TType.STRING, 2)
      oprot.writeString(self.pwd)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tid)
    value = (value * 31) ^ hash(self.pwd)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timAck_args:
  """
  Attributes:
   - ab
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ab', (TimAckBean, TimAckBean.thrift_spec), None, ), # 1
  )

  def __init__(self, ab=None,):
    self.ab = ab

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ab = TimAckBean()
          self.ab.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timAck_args')
    if self.ab is not None:
      oprot.writeFieldBegin('ab', TType.STRUCT, 1)
      self.ab.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ab)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timPresence_args:
  """
  Attributes:
   - pbean
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pbean', (TimPBean, TimPBean.thrift_spec), None, ), # 1
  )

  def __init__(self, pbean=None,):
    self.pbean = pbean

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pbean = TimPBean()
          self.pbean.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timPresence_args')
    if self.pbean is not None:
      oprot.writeFieldBegin('pbean', TType.STRUCT, 1)
      self.pbean.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pbean)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timMessage_args:
  """
  Attributes:
   - mbean
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'mbean', (TimMBean, TimMBean.thrift_spec), None, ), # 1
  )

  def __init__(self, mbean=None,):
    self.mbean = mbean

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.mbean = TimMBean()
          self.mbean.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timMessage_args')
    if self.mbean is not None:
      oprot.writeFieldBegin('mbean', TType.STRUCT, 1)
      self.mbean.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mbean)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timPing_args:
  """
  Attributes:
   - threadId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'threadId', None, None, ), # 1
  )

  def __init__(self, threadId=None,):
    self.threadId = threadId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.threadId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timPing_args')
    if self.threadId is not None:
      oprot.writeFieldBegin('threadId', TType.STRING, 1)
      oprot.writeString(self.threadId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.threadId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timError_args:
  """
  Attributes:
   - e
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'e', (TimError, TimError.thrift_spec), None, ), # 1
  )

  def __init__(self, e=None,):
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.e = TimError()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timError_args')
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.e)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timLogout_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timLogout_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timRegist_args:
  """
  Attributes:
   - tid
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tid', (Tid, Tid.thrift_spec), None, ), # 1
    (2, TType.STRING, 'auth', None, None, ), # 2
  )

  def __init__(self, tid=None, auth=None,):
    self.tid = tid
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tid = Tid()
          self.tid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.auth = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timRegist_args')
    if self.tid is not None:
      oprot.writeFieldBegin('tid', TType.STRUCT, 1)
      self.tid.write(oprot)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRING, 2)
      oprot.writeString(self.auth)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tid)
    value = (value * 31) ^ hash(self.auth)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timRoser_args:
  """
  Attributes:
   - roster
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'roster', (TimRoster, TimRoster.thrift_spec), None, ), # 1
  )

  def __init__(self, roster=None,):
    self.roster = roster

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.roster = TimRoster()
          self.roster.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timRoser_args')
    if self.roster is not None:
      oprot.writeFieldBegin('roster', TType.STRUCT, 1)
      self.roster.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.roster)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timMessageList_args:
  """
  Attributes:
   - mbeanList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'mbeanList', (TimMBeanList, TimMBeanList.thrift_spec), None, ), # 1
  )

  def __init__(self, mbeanList=None,):
    self.mbeanList = mbeanList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.mbeanList = TimMBeanList()
          self.mbeanList.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timMessageList_args')
    if self.mbeanList is not None:
      oprot.writeFieldBegin('mbeanList', TType.STRUCT, 1)
      self.mbeanList.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mbeanList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timPresenceList_args:
  """
  Attributes:
   - pbeanList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pbeanList', (TimPBeanList, TimPBeanList.thrift_spec), None, ), # 1
  )

  def __init__(self, pbeanList=None,):
    self.pbeanList = pbeanList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pbeanList = TimPBeanList()
          self.pbeanList.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timPresenceList_args')
    if self.pbeanList is not None:
      oprot.writeFieldBegin('pbeanList', TType.STRUCT, 1)
      self.pbeanList.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pbeanList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timMessageIq_args:
  """
  Attributes:
   - timMsgIq
   - iqType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'timMsgIq', (TimMessageIq, TimMessageIq.thrift_spec), None, ), # 1
    (2, TType.STRING, 'iqType', None, None, ), # 2
  )

  def __init__(self, timMsgIq=None, iqType=None,):
    self.timMsgIq = timMsgIq
    self.iqType = iqType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.timMsgIq = TimMessageIq()
          self.timMsgIq.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.iqType = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timMessageIq_args')
    if self.timMsgIq is not None:
      oprot.writeFieldBegin('timMsgIq', TType.STRUCT, 1)
      self.timMsgIq.write(oprot)
      oprot.writeFieldEnd()
    if self.iqType is not None:
      oprot.writeFieldBegin('iqType', TType.STRING, 2)
      oprot.writeString(self.iqType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.timMsgIq)
    value = (value * 31) ^ hash(self.iqType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timMessageResult_args:
  """
  Attributes:
   - mbean
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'mbean', (TimMBean, TimMBean.thrift_spec), None, ), # 1
  )

  def __init__(self, mbean=None,):
    self.mbean = mbean

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.mbean = TimMBean()
          self.mbean.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timMessageResult_args')
    if self.mbean is not None:
      oprot.writeFieldBegin('mbean', TType.STRUCT, 1)
      self.mbean.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mbean)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timProperty_args:
  """
  Attributes:
   - tpb
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tpb', (TimPropertyBean, TimPropertyBean.thrift_spec), None, ), # 1
  )

  def __init__(self, tpb=None,):
    self.tpb = tpb

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tpb = TimPropertyBean()
          self.tpb.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timProperty_args')
    if self.tpb is not None:
      oprot.writeFieldBegin('tpb', TType.STRUCT, 1)
      self.tpb.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tpb)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timRemoteUserAuth_args:
  """
  Attributes:
   - tid
   - pwd
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tid', (Tid, Tid.thrift_spec), None, ), # 1
    (2, TType.STRING, 'pwd', None, None, ), # 2
    (3, TType.STRUCT, 'auth', (TimAuth, TimAuth.thrift_spec), None, ), # 3
  )

  def __init__(self, tid=None, pwd=None, auth=None,):
    self.tid = tid
    self.pwd = pwd
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tid = Tid()
          self.tid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pwd = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.auth = TimAuth()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timRemoteUserAuth_args')
    if self.tid is not None:
      oprot.writeFieldBegin('tid', TType.STRUCT, 1)
      self.tid.write(oprot)
      oprot.writeFieldEnd()
    if self.pwd is not None:
      oprot.writeFieldBegin('pwd', TType.STRING, 2)
      oprot.writeString(self.pwd)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 3)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tid)
    value = (value * 31) ^ hash(self.pwd)
    value = (value * 31) ^ hash(self.auth)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timRemoteUserAuth_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TimRemoteUserBean, TimRemoteUserBean.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TimRemoteUserBean()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timRemoteUserAuth_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timRemoteUserGet_args:
  """
  Attributes:
   - tid
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tid', (Tid, Tid.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'auth', (TimAuth, TimAuth.thrift_spec), None, ), # 2
  )

  def __init__(self, tid=None, auth=None,):
    self.tid = tid
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tid = Tid()
          self.tid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.auth = TimAuth()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timRemoteUserGet_args')
    if self.tid is not None:
      oprot.writeFieldBegin('tid', TType.STRUCT, 1)
      self.tid.write(oprot)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 2)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tid)
    value = (value * 31) ^ hash(self.auth)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timRemoteUserGet_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TimRemoteUserBean, TimRemoteUserBean.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TimRemoteUserBean()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timRemoteUserGet_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timRemoteUserEdit_args:
  """
  Attributes:
   - tid
   - ub
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tid', (Tid, Tid.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ub', (TimUserBean, TimUserBean.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'auth', (TimAuth, TimAuth.thrift_spec), None, ), # 3
  )

  def __init__(self, tid=None, ub=None, auth=None,):
    self.tid = tid
    self.ub = ub
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tid = Tid()
          self.tid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ub = TimUserBean()
          self.ub.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.auth = TimAuth()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timRemoteUserEdit_args')
    if self.tid is not None:
      oprot.writeFieldBegin('tid', TType.STRUCT, 1)
      self.tid.write(oprot)
      oprot.writeFieldEnd()
    if self.ub is not None:
      oprot.writeFieldBegin('ub', TType.STRUCT, 2)
      self.ub.write(oprot)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 3)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tid)
    value = (value * 31) ^ hash(self.ub)
    value = (value * 31) ^ hash(self.auth)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timRemoteUserEdit_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TimRemoteUserBean, TimRemoteUserBean.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TimRemoteUserBean()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timRemoteUserEdit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timResponsePresence_args:
  """
  Attributes:
   - pbean
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pbean', (TimPBean, TimPBean.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'auth', (TimAuth, TimAuth.thrift_spec), None, ), # 2
  )

  def __init__(self, pbean=None, auth=None,):
    self.pbean = pbean
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pbean = TimPBean()
          self.pbean.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.auth = TimAuth()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timResponsePresence_args')
    if self.pbean is not None:
      oprot.writeFieldBegin('pbean', TType.STRUCT, 1)
      self.pbean.write(oprot)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 2)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pbean)
    value = (value * 31) ^ hash(self.auth)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timResponsePresence_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TimResponseBean, TimResponseBean.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TimResponseBean()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timResponsePresence_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timResponseMessage_args:
  """
  Attributes:
   - mbean
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'mbean', (TimMBean, TimMBean.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'auth', (TimAuth, TimAuth.thrift_spec), None, ), # 2
  )

  def __init__(self, mbean=None, auth=None,):
    self.mbean = mbean
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.mbean = TimMBean()
          self.mbean.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.auth = TimAuth()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timResponseMessage_args')
    if self.mbean is not None:
      oprot.writeFieldBegin('mbean', TType.STRUCT, 1)
      self.mbean.write(oprot)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 2)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mbean)
    value = (value * 31) ^ hash(self.auth)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timResponseMessage_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TimResponseBean, TimResponseBean.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TimResponseBean()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timResponseMessage_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timResponseMessageIq_args:
  """
  Attributes:
   - timMsgIq
   - iqType
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'timMsgIq', (TimMessageIq, TimMessageIq.thrift_spec), None, ), # 1
    (2, TType.STRING, 'iqType', None, None, ), # 2
    (3, TType.STRUCT, 'auth', (TimAuth, TimAuth.thrift_spec), None, ), # 3
  )

  def __init__(self, timMsgIq=None, iqType=None, auth=None,):
    self.timMsgIq = timMsgIq
    self.iqType = iqType
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.timMsgIq = TimMessageIq()
          self.timMsgIq.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.iqType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.auth = TimAuth()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timResponseMessageIq_args')
    if self.timMsgIq is not None:
      oprot.writeFieldBegin('timMsgIq', TType.STRUCT, 1)
      self.timMsgIq.write(oprot)
      oprot.writeFieldEnd()
    if self.iqType is not None:
      oprot.writeFieldBegin('iqType', TType.STRING, 2)
      oprot.writeString(self.iqType)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 3)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.timMsgIq)
    value = (value * 31) ^ hash(self.iqType)
    value = (value * 31) ^ hash(self.auth)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timResponseMessageIq_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TimMBeanList, TimMBeanList.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TimMBeanList()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timResponseMessageIq_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timResponsePresenceList_args:
  """
  Attributes:
   - pbeanList
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pbeanList', (TimPBeanList, TimPBeanList.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'auth', (TimAuth, TimAuth.thrift_spec), None, ), # 2
  )

  def __init__(self, pbeanList=None, auth=None,):
    self.pbeanList = pbeanList
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pbeanList = TimPBeanList()
          self.pbeanList.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.auth = TimAuth()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timResponsePresenceList_args')
    if self.pbeanList is not None:
      oprot.writeFieldBegin('pbeanList', TType.STRUCT, 1)
      self.pbeanList.write(oprot)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 2)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pbeanList)
    value = (value * 31) ^ hash(self.auth)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timResponsePresenceList_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TimResponseBean, TimResponseBean.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TimResponseBean()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timResponsePresenceList_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timResponseMessageList_args:
  """
  Attributes:
   - mbeanList
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'mbeanList', (TimMBeanList, TimMBeanList.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'auth', (TimAuth, TimAuth.thrift_spec), None, ), # 2
  )

  def __init__(self, mbeanList=None, auth=None,):
    self.mbeanList = mbeanList
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.mbeanList = TimMBeanList()
          self.mbeanList.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.auth = TimAuth()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timResponseMessageList_args')
    if self.mbeanList is not None:
      oprot.writeFieldBegin('mbeanList', TType.STRUCT, 1)
      self.mbeanList.write(oprot)
      oprot.writeFieldEnd()
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 2)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mbeanList)
    value = (value * 31) ^ hash(self.auth)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timResponseMessageList_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TimResponseBean, TimResponseBean.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TimResponseBean()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timResponseMessageList_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
